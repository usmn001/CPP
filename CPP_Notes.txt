***************Object Oriented Data Structures In C++**************************

             ***********************Week 1 **********************

C++ just like C is a strongly typed language meaning that every variable has a type name,value and location in memory i.e. data_type var_name = assigned_value; The C compiler assigns memory to variable after when it´s defined and assigned value.

In c++ there is also a keyword auto used when we want the compiler to decide the data type of varaible through the assigned value for e.g. 
like in this variable declaration auto n{64} the compiler is has assumed that n is a integer variable as assigned value to variable n is of int data type.

C++ Types/Dat Types : In C++ we have two main types of variables defining contents of it i.e. 

Primitive : char,int,bool,float,double,void. (Exactly like we have in C)
To avoid garbage random value to be assigned at the time of compilation to variables we should initialze our variable like this : 
int n=0 or int n{}, we can say that data_type var_name{} or data_type var_name=0,

User Defined : An unlimited number of user defined types which we can create by ourselves are available.
Two of the most common user-defined types are : 
std::string , a string (squence of characters).
std::vector, a dynamically-growing array.
Here std means standard library however it´s implementation depends upon creators of Operating systems and compilers that´s why here it was referred as standard library. It´s built in same way that we can define our own complex types and libraries.

C++ Build process involves : Preprocessing done by preprocessor, Compilation done by compiler and linking done by linker just like it´s done with case of C Program Build Process.

endl keyword is used with cout command for moving to the next line and it also flushes the output moreover we can also use \n for performing the same operation depending upon our team coding style.

iostream library header file containing cout and cin definitions.

Unlike C library header files in C++ don´t require .h suffix after their name in case of standard and system header files when including them using preprocessor directive include for e.g.

#include <iostream>

For using user defined we use .h notation after header file name.

.cpp and .cc are common extensions used alongwith names c++ files.

To compile c++ program from command line or linux terminal we use gcc compiler
and to do it we use command  "g++ codefilename.cpp" then we get executable file with .out
extension. We can also use a flag while compiling for defining name of output executable file
and we do it by using -o flag as g++ -o executable_name source_code.cpp

The relational operators == , != returns true or false depending upon whether the condition is satisfied or not and these return values are defined are in bool.h header file.

Variable Declaration in c++ is similar to c where we had char, int, float, double,long,short data types for storing a certain value.


--------------------C++ Classes-----------------

In C++ both data and functions are encapuslated into a class with access specifiers public and private.
We refer both data and functions residing in a class as it´s members.

Public Members(Data & Functions) can be accessed by client code i.e. outside of class.
Private Members(Data & Functions) cannot be accessed by client code , can only be accessed within class.

In C++ just like C we have our header file where we function prototypes i.e. declaration of member functions and declaration of all member variables shared among other source files.
Simiarly we have our include guards in the header file just like C to make sure header file is only included once i.e. #ifndef _HeaderFileName_
                   #define _HeaderFileName_       
                   ....
                   ....
                   #endif

We can also use #pragma once (pre processor directive) to make sure that our class header file is included only once.  

General Format of Creating A Class File .h and Declaring Functions In It is : 

Class_name.h  : 
// Include guards or #pragma once 

Class class_name{

access_specifier :                                   Note : Where access specifier can be public or private similar to static and extern storage classes in C language
         return_type func_name();
         data_type var_name;
access_specifier : 
        return_type func_name();
        struct name{

        };
}


Format for Class Implementation file .cpp containing class function definitions

Class_name.cpp : 

#include "Class_name.h"

return_data_type Class_name::func_name(){                Note : This return data type can be void just like in C.
           // Function Implementation                    Note : Class Private Variables are accessed by in Client Code by Setters and Getters Functions of Class.  
}                                                        Note : Private Variables of class are defined or accessed only in client code.  

Example : 
Implementation of functions are in .cpp file similarly to .c file for C.

Example : Class and implementation files of a geometric structure cube

Class file : Cube.h

#pragma once

class Cube {

public : 
        double getVolume();
        double getSurfaceArea();
        void setLength(double length);

private : double length_; 

};

Class Implementation file : Cube.cpp
#include "Cube.h"

  double Cube::getVolume(){            // Where double is return type of function  getVolume previously declared in Cube.h header file
   return length_*length_*length_;
}

  double Cube::getSurfaceArea(){
    return 6*length_*length_;
 } 
   
  void Cube::setLength(double length){
     length_= length;  
   }


Main Thread : 

#include "Cube.h"
using namespace std;
int main(){
Cube c;
c.setlength(3.48);
double volume = c.getvolume();
cout<<"Volume : "<<volume<<endl;
return 0;
}

----------------------C++ Standard Library (std)-------------------------------

C++ standard library (STD) provides us a set of commonly used functionality and data structures to build upon. The C++ standard library is also known as Standard Template Library (STL)

The C++ standard library is organized into many separate sub-libraries that can be #included in any C++ program. iostream sub library is also part of this std library.

All functionality used from the standard library will be part of std namespace.
Namespaces allow us to avoid name conflicts for commonly used names.
If a feature from a namespace is used often, it can be imported into the global space with "using" :
using std ::cout; this line of code will allow us to use cout without prefix of std::

------Using the uiuc Namespace---------

As our class Cube is generic and from that we can create hundreds of Cube based data structures so to specify our Cube class within uiuc namespace in this way : 

A cube is rather generic name and hundreds of cube based data structures exist and we want to be specific
about our Cube and specify that our Cube is within uiuc namespace.

Example 3 : Class Header file and Implementation file using namespace

Class Header file : Cube.h

#pragma once
namespace uiuc{          ------ Class cube encapsulation in uiuc namespace start here-----

class Cube {

public : 
        double getVolume();
        double getSurfaceArea();
        void setLength(double length);

private : double length_; 

};

}                         ------- Class cube encapsulation in uiuc namespace ends--------

Class Implementation file : Cube.cpp

#include "Cube.h"

namespace uiuc{                   ------ Class cube encapsulation in uiuc namespace start here-----

  double Cube::getVolume(){
   return length_*length_*length_;
}

  double Cube::getSurfaceArea(){
    return 6*length_*length_;
 } 
   
  void Cube::setLength(double length){
     length_= length;  
   }

}                                   ------- Class cube encapsulation in uiuc namespace ends--------

Main source code : 
#include <iostream>
#include "Cube.h"
using std::cout;
using std::endl;

int main(){
uiuc::Cube c;
c.setlength(3.48);
double volume = c.getvolume();
cout<<"Volume : "<<volume<<endl;
double surfaceArea = c.getSurfaceArea();
cout<<"Surface Area : "<< surfaceArea << endl;
return 0;
}

 
--------------------------------Week 2 : C++ Mmeory Model----------------------------

All variables in C++ reside in stack memory just like C.

C++ pointers are decalred in the same way just like we used to do with C. i.e. data_type * var_name; 

C++ follows exacty the same memory model as we found in C language both for data and code memory.

Heap is defined by new keyword in C++ and released by delete[] heap_ptr statement. 

Heap memory is accessed by pointer.

Example : heap_ptr=new data_type(size to be allocated); 
<<<<<<< HEAD
=======


-----------------------------------------------------------Week 3 :  Developing C++ Classes---------------------------------------------------------- 

------------------------------Lec : 1,2,3,5 -------------------------------------


In C++ class constructors are used to initialize member variables, copy one object to another object (copy class constructors), assign entire one object to another 
(copy assignment operator), free memroy(stack,heap) occupied by class object (class destructor). 
By default c++ compiler provides us free default constructor, copy class constructor, class assignment operator,Class Destructor even if we don´t define any.

Syntax Of Declaring Copy Constructor, Copy Assignment Operator In Class Header File : 

                         Class_Name()                                    // Custom Class Constructor. 
                         Class_Name(const class_name &obj)               // Copy Constructor, Where const class_name means that we have a constant class passed by reference object.
                         Class_Name & operator=(const class_name &obj)   // Copy Assignment Operator, Where const class_name means that we have a constant class passed by reference object.                                    
                        ~Class_Name();                                   // Class Destructor.
     
Syntax of Defining Copy Constructor, Copy Assignment Operator, Class Destructor In Class Definition File :

                         Class_Name::Class_Name()                                            // Custom Class Constructor
                         {
                               //Custom Class Constructor
                         }
			  
                         Class_Name::Class_Name(const Class_Name &obj)                      // Custom Copy Constructor , Inoked Upon : Passing an object to function.
                                                                                                                                        Returning an Object from a function.    
                         {                                                                                                              Initializing a new object.
  		          // Copy Constructor Body                                                         
 			 }

                         Class_Name & Class_Name::operator=(const Class_Name &obj)          // Custom Copy Assignment Operator, Assigns a value to an existing object
  			 { 
                         // Assignment Operator                                                         
 			 }

                         Class_Name::~Class_Name()                                          // Custom Class Destructor
                         {  
                          
                          }
                                                                           

Example 1 : 

Class Cube.h Header File (Declaration File)
#include <stdint.h>
#pragma once

// A class is defined with the `class` keyword, the name
// of the class, curly braces, and a required semicolon
// at the end:
namespace uiuc {

class Cube {
  public:  // Public members:
    Cube();                                  // Custom Default Constructor
    Cube(const Cube &obj);                   // Custom Copy Constructor
    ~Cube();                                 // Custom Class Destructor
    Cube & operator=(const Cube &obj);       // Custom Copy Assignment Operator
    double getVolume();
    double getSurfaceArea();
    void setLength(uint8_t length);

  private: // Private members:
    double length_new;
    int *pa;
};

}
Class Cube.cpp Definition File

#include "Cube.h"
#include <stdint.h>
#include <iostream>
#include<math.h>
using std::cout;
using std::endl;

namespace uiuc{

 Cube::Cube(){                                  // Custom Default Constructor
  length_new = 1;
  cout<<"Default Constructor Is Invoked"<<endl;
 }

 
 Cube::Cube(const Cube &obj){                  // Custom Copy Constructor
  length_new = obj.length_new;
  cout<<"Copy Constructor Is Invoked"<<endl;
 }

Cube::~Cube(){                                 // Custom Class Destructor
  cout<<"Destructor Is Invoked"<<endl;
}

Cube & Cube::operator=(const Cube &obj){       // Custom Copy Assignment Operator
  length_new = obj.length_new;
  cout<<"Copy Assignment Operator Is Invoked"<<endl;
  return *this;
 }

double Cube::getVolume() {
  return pow(length_new,3);
}

double Cube::getSurfaceArea() {
  return 6 * pow(length_new,2);
}

void Cube::setLength(uint8_t length) {
  length_new = length;
}

}


Main Source File Code : 

int main() {
  Cube c;                          // Default Constructor is invoked.
  Cube d ;                         // Default Constructor is invoked.
  d=c;                             // Assignment operator is invoked.                 
  Cube * cn = CreateUnitCube(c);   // Passing argument to function by value, Copy Class Constructor Invoked 
                                   // Two times First At Passing Value to a function and then returning from it.

}

----------------------Lec 4 : Variable Storage--------------------

In C++ we can also pass data to a function through reference , it´s called pass by reference, enabling us to access same memory location, a bit similar to pointers.
To create a reference we follow the syntax : data_type & ref_var_name = var_name; Where data_type can also be a class.

Example : Pass By Reference. 

void add(Cube &al){
al.setLength(8);
cout<<"Alias used";
}

int main() {
Cube c;                          // Default Constructor is invoked.
Cube & alc = c;                  // Default constructor is already invoked for object as here we have only alias for object c.
add(alc);
}  


-----------Modern Range Base For Loop, Vector Template Type----------------


Example : Showing Use Of Vector and Modern Range Based For Loop

#include <vector>

int main()
{

// Vector

std::vector<int> list={0,1,2,3};   // The vector is a generic data structure in C++ provided to us by STL.
                                   // Similar to an array.

// Range Based For Loop

for(int lval : list){              // We are copying values of list elements to lval variable one by one.
cout<<"List Element = "<<lval<<endl;  
}


list.push_back(100);               // Adding value 100 to list
list.push_back(101);               // Adding value 101 to list
list.pop_back();
for(int lval : list){              // We are copying values of list elements to lval variable one by one.
cout<<"After Push Operations List Elements Are : "<<lval<<endl;     
}

return 0;
}


-----------------------------------------------Week 4 : Engineering C++ Software Solutions--------------------------------------------------------


--------------------Lec 1 : Template Types-----------------------


In C++ template type is a special type that can take on different types when type is initialized.
A bit simlar to typedef user defined types of C. 

STD/STL library of C++ provides us vector a standard library class providing the functionlaity of 
dynamically growing array with a templated type. This is :-

Defined in       	                :		 #include <vector>
Initializiation         		:		 std::vector<T> v;
Add Element to (back) of array  	:		 v.push_back(T);
Adding Class Object To Back Of Array    :                v[location].push_back(T); // Where T is object and location is index of vector
                                                 
Subtraction from back   		: 		 v.pop_back(T);
Access specific element                 :		 v.[0] = val_to_assign ; 
                          				 v.[0] 
Number of elements      		:                v.size(); 


Example : This statement is pushing stackOfCubes objects onto the vector stacks.
 for (int i = 0; i < 3; i++) {
    Stack stackOfCubes;
    stacks_.push_back( stackOfCubes );
  }

When we push an object on stack then we can perform all supported operations (functions defined in class) on that object by accessing it through the index of vector.


---------------------Lec 5 : Templates and Classes--------------------------

C++ allows us to use the power of templates in building our own classes.

Templates in C++ are similar to variadic functions or typedef of C. 

Templates allow us to pass paramters of any type to functions or declare a variable with a template type.

Data type of a template variable is defined at compile time.

A Template variable is defined at the begining of a class or function.

A function can also return a template type.

Template variables are checked at compile time, allowing errors to be caught at compile time before running the program.

Syntax of Declaring a Template variable : template <typename T>

----------Example 1 : Templated Class---------- 

template <typename T>

class class_name{


private : T data_;   // where data_ is a template variable.
};

---------Example 2 : Templated Function-----------

template <template T>
int max (T a, T b) //where a and b are template variables, their data type will be defined automatically at compile time.
{
if(a > b) {return a ;}
return b;
}
  
----------------Example 3 : ----------------------

#include <iostream>
#include <string>
using std::cout;
using std::endl;

#include "Cube.h"
using uiuc::Cube;

// We'll call this my_max to avoid conflicts with the "max" in the
// standard libraries.
template <typename T>
T my_max(T a, T b) {             // Here function is returning a template type.
  if (a > b) { return a; }
  return b;
}

int main() {
  cout << "my_max(3, 5): " << my_max(3, 5) << endl;
  cout << "my_max('a', 'd'): " << my_max('a', 'd') << endl;
  
  // Here we construct std::string objects from the literal strings in
  // quotation marks, because the std::string object already implements
  // the ">" operator to do alphabetical ordering. A plain string literal
  // is an array of const char, which wouldn't support that correctly.
  // (Instead, it would just compare the addresses of the arrays.)
  cout << "my_max(std::string(\"Hello\"), std::string(\"World\")): "
       << my_max(std::string("Hello"), std::string("World")) << endl;

  // You need to finish implementing the ">" operator for Cube to get the
  // next line to work!
  // cout << "my_max( Cube(3), Cube(6) ): " << my_max( Cube(3), Cube(6) ) << endl;

  return 0;
}


Note : In C++ when we use const keyword with a function definition inside a class that means it´s denied permission to change values of data members of their class.


---------------------Lec 5 : Inheritance-------------------

In C++ and other object oriented programming languages, Inheritance allows a derived class to 
inherit all the member functions and variables of a base class. 

To derived properties from base class into a derived class we append a colon (:) in derived class header file i.e. 
                                                                          
                                                                          class derived_class_name : public or private base_class_name {          
                                                                          
                                                                          // Class member functions or variables.   
                                                                                                                        
                                                                          };
                                               
We also need to include base class header file in derived class header/declaration file.

As we already know that to use a class we need to first initialize it by calling it´s constructor, 
Similarly to use a base class inside a derived class we will first need to initialize it through it´s constructor. It should be noted that we need to first initialize base class . 

The constructor for base class is called inside derived class definition file.

Base Class Shape Header file Shape.h : 

class Shape {
  public:
    Shape();
    Shape(double width);
    double getWidth() const;

  private:
    double width_;
};

Base Class Shape Definition File Shape.cpp :
 
#include "Shape.h"

Shape::Shape() : Shape(1) { // Here default constructor is calling constructor with a parameter
  // Nothing.
}

Shape::Shape(double width) : width_(width) {
  // Nothing.
}

double Shape::getWidth() const {
  return width_;
}


Example 1 : 

Derived class Cube.h header file & Definition File Cube.cpp  

Cube.h Header file : 

#include "Shape.h"                          // Where Shape is our base class
#include "HSLAPixel.h"

namespace uiuc {
  class Cube : public Shape {             // Here we are inheriting all the member functions and variables from base class named as Shape.
    public:
      Cube(double width, uiuc::HSLAPixel color);
      double getVolume() const;

    private:
      uiuc::HSLAPixel color_;
  };
}

Cube.cpp File : 

#include "Cube.h"
#include "Shape.h"

namespace uiuc {
  Cube::Cube(double width, uiuc::HSLAPixel color) : Shape(width) {             // Here we are constructing base class by calling it´s custom default constructor.
    color_ = color;
  }

  double Cube::getVolume() const {
    // Cannot access Shape::width_ due to it being `private`
    // ...instead we use the public Shape::getWidth(), a public function

    return getWidth() * getWidth() * getWidth();
  }
}


------Access Control---------------

When a base class is inherited, the derived class : 
Can access all public members of base class.
Can not access private members of base class.


----------------Initializer List---------------------
                                                                                                                 
Syntax to initialize a base class is called initializer list and can be used for several purposes i.e. : 

Initialize a base class .
Initialize current class using another constructor.
Initialize default values of member variables.


The above initialization steps are shown in the class definition of base class Shape.cpp : 


Base Class Shape Header File Shape.h : 

#pragma once

class Shape {
  public:
    Shape();
    Shape(double width);
    double getWidth() const;

  private:
    double width_;
}; 


Base Class Shape Definition File Shape.cpp :
 
#include "Shape.h"

Shape::Shape() : Shape(1) { // Here default constructor is calling constructor with a parameter(Shape double width) i.e. this defalut 
                            // constructor is using the logic of default constructor to initialize our object.
  // Nothing.
}

Shape::Shape(double width) : width_(width) {   // Here default constructor with a parameter is initializaing private member variable width.
                                               // Where width_ is private member variable of base class defined in it´s definition file Shape.cpp   
  // Nothing.
}

double Shape::getWidth() const {
  return width_;
}
>>>>>>> main


-----------------------------------------------------------Week 3 :  Developing C++ Classes---------------------------------------------------------- 

------------------------------Lec : 1,2,3,5 -------------------------------------


In C++ class constructors are used to initialize member variables, copy one object to another object (copy class constructors), assign entire one object to another 
(copy assignment operator), free memroy(stack,heap) occupied by class object (class destructor). 
By default c++ compiler provides us free default constructor, copy class constructor, class assignment operator,Class Destructor even if we don´t define any.

Syntax Of Declaring Copy Constructor, Copy Assignment Operator In Class Header File : 

                         Class_Name()                                    // Custom Class Constructor. 
                         Class_Name(const class_name &obj)               // Copy Constructor, Where const class_name means that we have a constant class passed by reference object.
                         Class_Name & operator=(const class_name &obj)   // Copy Assignment Operator, Where const class_name means that we have a constant class passed by reference object.                                    
                        ~Class_Name();                                   // Class Destructor.
     
Syntax of Defining Copy Constructor, Copy Assignment Operator, Class Destructor In Class Definition File :

                         Class_Name::Class_Name()                                            // Custom Class Constructor
                         {
                               //Custom Class Constructor
                         }
			  
                         Class_Name::Class_Name(const Class_Name &obj)                      // Custom Copy Constructor , Inoked Upon : Passing an object to function.
                                                                                                                                        Returning an Object from a function.    
                         {                                                                                                              Initializing a new object.
  		          // Copy Constructor Body                                                         
 			 }

                         Class_Name & Class_Name::operator=(const Class_Name &obj)          // Custom Copy Assignment Operator, Assigns a value to an existing object
  			 { 
                         // Assignment Operator                                                         
 			 }

                         Class_Name::~Class_Name()                                          // Custom Class Destructor
                         {  
                          
                          }
                                                                           

Example 1 : 

Class Cube.h Header File (Declaration File)
#include <stdint.h>
#pragma once

// A class is defined with the `class` keyword, the name
// of the class, curly braces, and a required semicolon
// at the end:
namespace uiuc {

<<<<<<< HEAD
class Cube {
  public:  // Public members:
    Cube();                                  // Custom Default Constructor
    Cube(const Cube &obj);                   // Custom Copy Constructor
    ~Cube();                                 // Custom Class Destructor
    Cube & operator=(const Cube &obj);       // Custom Copy Assignment Operator
    double getVolume();
    double getSurfaceArea();
    void setLength(uint8_t length);
=======

>>>>>>> main

  private: // Private members:
    double length_new;
    int *pa;
};

}
Class Cube.cpp Definition File

#include "Cube.h"
#include <stdint.h>
#include <iostream>
#include<math.h>
using std::cout;
using std::endl;

namespace uiuc{

 Cube::Cube(){                                  // Custom Default Constructor
  length_new = 1;
  cout<<"Default Constructor Is Invoked"<<endl;
 }

 
 Cube::Cube(const Cube &obj){                  // Custom Copy Constructor
  length_new = obj.length_new;
  cout<<"Copy Constructor Is Invoked"<<endl;
 }

Cube::~Cube(){                                 // Custom Class Destructor
  cout<<"Destructor Is Invoked"<<endl;
}

Cube & Cube::operator=(const Cube &obj){       // Custom Copy Assignment Operator
  length_new = obj.length_new;
  cout<<"Copy Assignment Operator Is Invoked"<<endl;
  return *this;
 }

double Cube::getVolume() {
  return pow(length_new,3);
}

double Cube::getSurfaceArea() {
  return 6 * pow(length_new,2);
}

void Cube::setLength(uint8_t length) {
  length_new = length;
}

}


Main Source File Code : 

int main() {
  Cube c;                          // Default Constructor is invoked.
  Cube d ;                         // Default Constructor is invoked.
  d=c;                             // Assignment operator is invoked.                 
  Cube * cn = CreateUnitCube(c);   // Passing argument to function by value, Copy Class Constructor Invoked 
                                   // Two times First At Passing Value to a function and then returning from it.

}

----------------------Lec 4 : Variable Storage--------------------

In C++ we can also pass data to a function through reference , it´s called pass by reference, enabling us to access same memory location, a bit similar to pointers.
To create a reference we follow the syntax : data_type & ref_var_name = var_name; Where data_type can also be a class.

Example : Pass By Reference. 

void add(Cube &al){
al.setLength(8);
cout<<"Alias used";
}

int main() {
Cube c;                          // Default Constructor is invoked.
Cube & alc = c;                  // Default constructor is already invoked for object as here we have only alias for object c.
add(alc);
}  


-----------Modern Range Base For Loop, Vector Template Type----------------


Example : Showing Use Of Vector and Modern Range Based For Loop

#include <vector>

int main()
{

// Vector

std::vector<int> list={0,1,2,3};   // The vector is a generic data structure in C++ provided to us by STL.
                                   // Similar to an array.

// Range Based For Loop

for(int lval : list){              // We are copying values of list elements to lval variable one by one.
cout<<"List Element = "<<lval<<endl;  
}


list.push_back(100);               // Adding value 100 to list
list.push_back(101);               // Adding value 101 to list
list.pop_back();
for(int lval : list){              // We are copying values of list elements to lval variable one by one.
cout<<"After Push Operations List Elements Are : "<<lval<<endl;     
}

return 0;
}


-----------------------------------------------Week 4 : Engineering C++ Software Solutions--------------------------------------------------------


--------------------Lec 1 : Template Types-----------------------


In C++ template type is a special type that can take on different types when type is initialized.
A bit simlar to typedef user defined types of C. 

STD/STL library of C++ provides us vector a standard library class providing the functionlaity of 
dynamically growing array with a templated type. This is :-

Defined in       	                :		 #include <vector>
Initializiation         		:		 std::vector<T> v;
Add Element to (back) of array  	:		 v.push_back(T);
Adding Class Object To Back Of Array    :                v[location].push_back(T); // Where T is object and location is index of vector
                                                 
Subtraction from back   		: 		 v.pop_back(T);
Access specific element                 :		 v.[0] = val_to_assign ; 
                          				 v.[0] 
Number of elements      		:                v.size(); 


Example : This statement is pushing stackOfCubes objects onto the vector stacks.
 for (int i = 0; i < 3; i++) {
    Stack stackOfCubes;
    stacks_.push_back( stackOfCubes );
  }

When we push an object on stack then we can perform all supported operations (functions defined in class) on that object by accessing it through the index of vector.


---------------------Lec 5 : Templates and Classes--------------------------

C++ allows us to use the power of templates in building our own classes.

Templates in C++ are similar to variadic functions or typedef of C. 

Templates allow us to pass paramters of any type to functions or declare a variable with a template type.

Data type of a template variable is defined at compile time.

A Template variable is defined at the begining of a class or function.

A function can also return a template type.

Template variables are checked at compile time, allowing errors to be caught at compile time before running the program.

Syntax of Declaring a Template variable : template <typename T>

----------Example 1 : Templated Class---------- 

template <typename T>

class class_name{


private : T data_;   // where data_ is a template variable.
};

---------Example 2 : Templated Function-----------

template <template T>
int max (T a, T b) //where a and b are template variables, their data type will be defined automatically at compile time.
{
if(a > b) {return a ;}
return b;
}
  
----------------Example 3 : ----------------------

#include <iostream>
#include <string>
using std::cout;
using std::endl;

#include "Cube.h"
using uiuc::Cube;

// We'll call this my_max to avoid conflicts with the "max" in the
// standard libraries.
template <typename T>
T my_max(T a, T b) {             // Here function is returning a template type.
  if (a > b) { return a; }
  return b;
}

int main() {
  cout << "my_max(3, 5): " << my_max(3, 5) << endl;
  cout << "my_max('a', 'd'): " << my_max('a', 'd') << endl;
  
  // Here we construct std::string objects from the literal strings in
  // quotation marks, because the std::string object already implements
  // the ">" operator to do alphabetical ordering. A plain string literal
  // is an array of const char, which wouldn't support that correctly.
  // (Instead, it would just compare the addresses of the arrays.)
  cout << "my_max(std::string(\"Hello\"), std::string(\"World\")): "
       << my_max(std::string("Hello"), std::string("World")) << endl;

  // You need to finish implementing the ">" operator for Cube to get the
  // next line to work!
  // cout << "my_max( Cube(3), Cube(6) ): " << my_max( Cube(3), Cube(6) ) << endl;

  return 0;
}


Note : In C++ when we use const keyword with a function definition inside a class that means it´s denied permission to change values of data members of their class.


---------------------Lec 5 : Inheritance-------------------

In C++ and other object oriented programming languages, Inheritance allows a derived class to 
inherit all the member functions and variables of a base class. 

To derived properties from base class into a derived class we append a colon (:) in derived class header file i.e. 
                                                                          
                                                                          class derived_class_name : public or private base_class_name {          
                                                                          
                                                                          // Class member functions or variables.   
                                                                                                                        
                                                                          };
                                               
We also need to include base class header file in derived class header/declaration file.

As we already know that to use a class we need to first initialize it by calling it´s constructor, 
Similarly to use a base class inside a derived class we will first need to initialize it through it´s constructor. It should be noted that we need to first initialize base class . 

The constructor for base class is called inside derived class definition file.

Base Class Shape Header file Shape.h : 

class Shape {
  public:
    Shape();
    Shape(double width);
    double getWidth() const;

  private:
    double width_;
};

Base Class Shape Definition File Shape.cpp :
 
#include "Shape.h"

Shape::Shape() : Shape(1) { // Here default constructor is calling constructor with a parameter
  // Nothing.
}

Shape::Shape(double width) : width_(width) {
  // Nothing.
}

double Shape::getWidth() const {
  return width_;
}


Example 1 : 

Derived class Cube.h header file & Definition File Cube.cpp  

Cube.h Header file : 

#include "Shape.h"                          // Where Shape is our base class
#include "HSLAPixel.h"

namespace uiuc {
  class Cube : public Shape {             // Here we are inheriting all the member functions and variables from base class named as Shape.
    public:
      Cube(double width, uiuc::HSLAPixel color);
      double getVolume() const;

    private:
      uiuc::HSLAPixel color_;
  };
}

Cube.cpp File : 

#include "Cube.h"
#include "Shape.h"

namespace uiuc {
  Cube::Cube(double width, uiuc::HSLAPixel color) : Shape(width) {             // Here we are constructing base class by calling it´s custom default constructor.
    color_ = color;
  }

  double Cube::getVolume() const {
    // Cannot access Shape::width_ due to it being `private`
    // ...instead we use the public Shape::getWidth(), a public function

    return getWidth() * getWidth() * getWidth();
  }
}


------Access Control---------------

When a base class is inherited, the derived class : 
Can access all public members of base class.
Can not access private members of base class.


----------------Initializer List---------------------
                                                                                                                 
Syntax to initialize a base class is called initializer list and can be used for several purposes i.e. : 

Initialize a base class .
Initialize current class using another constructor.
Initialize default values of member variables.


The above initialization steps are shown in the class definition of base class Shape.cpp : 


Base Class Shape Header File Shape.h : 

#pragma once

class Shape {
  public:
    Shape();
    Shape(double width);
    double getWidth() const;

  private:
    double width_;
}; 


Base Class Shape Definition File Shape.cpp :
 
#include "Shape.h"

Shape::Shape() : Shape(1) { // Here default constructor is calling constructor with a parameter(Shape double width) i.e. this defalut 
                            // constructor is using the logic of default constructor to initialize our object.
  // Nothing.
}

Shape::Shape(double width) : width_(width) {   // Here default constructor with a parameter is initializaing private member variable width.
                                               // Where width_ is private member variable of base class defined in it´s definition file Shape.cpp   
  // Nothing.
}

double Shape::getWidth() const {
  return width_;
}



******************Course 2 : Ordered Data Structures In C++********************


--------------------Week 1-----------------------

-----------------Lec 1 : Arrays------------------ 

In both C,C++ arrays are continous memory locations and have a fixed size and length.

To know the offset in bytes between two array indexes do offset = (long) (&arr[index2]) - (long) (&arr[index1]); // Here we are subtracting two addresses of two array elements stored at
                                                                                                                 // certain memory locations 


Similar to an array in C++ we have vector which shares all the properties of an array except that it can grow dynamically but at a time it will also have fixed size.
This vector is similar to heap memory which can be resized using realloc(heap_ptr,new_size).

If we have a array of fixed size then to increase it´s capactity we will need to copy entire elements of it to another array, or if we want to add another element.

In case of a vector we can increase the capacity by performing a push back operation on vector i.e. 

std::vector<data_type> vect_name { element1,...};
vect_name.push_back(data);

We can also iterate over a vector using a for loop similar to an array.

-------------Lec 2 : Linked Memory---------------------

In Linked List Head Pointer Points to first Node Address ,
               Tail Pointer Points to Last Node Address.

Just like in C where we used to have a linked list structure i.e. struct Node {
                                                                       struct Node *next;  // next pointer points to next memory allocation, this pointer is actually a heap memory pointer.
                                                                       data_type data;
                                                                   };

Similar in C++ we also have linked list linking memory locations together through next pointer. 

C++ Linked List Node Class :       // Very similar to Linked list Node structure found in C.

template <typename T>
class ListNode {
public : 
   	T & data;                                       // Reference Template Type.
	ListNode *next;                          
	ListNode(T & data) : data(data) : next(NULL);   // Where reference variable data is initialized to data and next pointer to NULL
};


List.h Header file :

#pragma once

template <typename T>
class List {
public : 
  const T & operator[](unisgned index);   // This operator ampersand is C++ syntax of mentioning that we can access a List <int> l as l[index]; Where l[index] will be calling this 
                                          // Function.   , const T is indicating function is returing a const template type.                                        
  void insertAtFront(const T & data);     // Inserting element in list

private : 
 class ListNode {
public : 
   	T & data;                                       // Reference Template Type.
	ListNode *next;                          
	ListNode(T & data) : data(data) , next(NULL);   // Where reference variable data is initialized to data and next pointer to NULL
};

ListNode *head_;                         // The head pointer points to the start of list i.e. first node.

};

In the above header file we have a class within a class similar to struct within a struct or union within a union and so on.

To iterate over linked list in C++ we define function const T & operator[](unisgned index) as :

--------Method : const T & operator[](unisgned index) Implementation -------------- 

template <typename T>
const T & List<T> operator[](unisgned index){          //Here at this line const T & means that this method is returning a reference to const template type T & data member of ListNode class inside List class.

ListNode *thru = head_;

while(index > 0 && thru->next !=nullptr)
{
thru = thru->next;
index --;
}

return thru->data;

}

List RunTime : It´s more than a array because here we need to pass through n numer of next pointers for accessing a certain node and it´s not fixed unlike an array, as the 
               list can grow at any time depending upon requirement.


To Insert an element in list we define method/function void insertAtFront(const T & data) as : 

--------Method : void List<T>::insertAtFront(const T & data) Implementation --------------
 
template <typename T>
void List<T>::insertAtFront(const T & data){

ListNode *new_node = new ListNode(data);

new_node->next = head_;    // new node next pointer points to current node

head_=new_node;            // The current head pointer is updated with new_node address.

}
 

----------Lec 3 : Run Time Analysis----------

Run Time Analysis : Allows us to formalize a method of comparing the speed of an algorithm as the size of input grows.

In a array of length l , size s, we can access a given index by : sizeof(index) * index; where sizeof(index) is the number of bytes occupied by a element at that index.
                                                                  This equation actually tells us the required offset in Bytes i.e. if array is of uint8_t type then to 
                                                                  access 5 location it will takes us 8 * 5 = 40 bytes offset.  

In a linked list as the list grows we will need more time to access a given element.

Run time analysis allows us to formalize a method of comparing the speed of an algorithm as the size of input grows.

We summarize the runtime in Big O Notation , leaving only the term that dominates the growth :
- O(1) , constant time
- O(n) , linear time.
- 0(n^2) , polynomial time.


---------------Lec 4 : Array and List Operations---------------- 


------Run Times For Finding A Data In Array, Linked List ------- 

Unsorted Array : O(n) 
                 Requires searching up to the full array, one-by-one, to find a match.

Sorted Array : O(log(n))
               Using Binary search, Run Time on an array becomes logarithmic.

All Lists : O(n) 
            Requires searching up to the full list, one listNode at a time, to find a match even
            if the list is sorted.

---------Run Time On Inserting A Element In Array, List----------

In A Array If Element or Data is Inserted In Middle : O(n)
In A List It´s Just : O(1) Because we just needed to update two nodes next pointers i.e.
                      the node after which we want to insert new node, new node next pointer 
                      poiniting to next successive node.
                
                   Nodes :  a b c
To insert a new node e in between b and c we do : b->next = e;
                                                  e->next = c;

To Insert Node e in the start of list we do : Node *old_hptr = a;
                                              e = a;
                                              e->next = a;
                                              a->prev = e;       (in case of doubly linked list)
                                              a->next = b;  
                                              

  
------Run Time To Delete An Element After---------

In Array : O(n)  As we will need to search the entire array of n elements.
List : O(1) As we just need to update next pointers of two successive nodes i.e.
                    
                  Nodes : a b c.
             To delete c from above linked list we do : b->next = null; // marking end of list.


Arrays and lists are both ordered data collections having complex tradeofs between run time and
flexibility.




------------Lec 5 : Queue (Data Structure)-----------


A structures  Abstract data type (ADT) is how data interacts with the structure, an ADT is not an implementation , it is a description.

Queue is FIFO (First in First out) data structure. In C++ queue is available to us in std/stl library. Queue also supports template type.

We need to support operations of create, push, pop and empty for our queue where : 
create 	: Creates an empty queue.
push 	: Adds data to the back of queue.
pop 	: Removes data from front of queue.
empty 	: Returns true if queue is empty.

So we can implement a queue besides already provided one using arrays and linked list.

Example 1 : Queue  

#include <iostream>
#include <queue>

int main() {
  // Create a std::queue:
  std::queue<std::string> q;        // here we can also have  queue of integers i.e. std::queue<std::int> i;

  // Add several strings to the queue:
  q.push( "Orange" );
  q.push( "Blue" );
  q.push( "Illinois" );

  // Print the front of the queue out and pop it off:
  std::cout << "First pop(): " << q.front() << std::endl;
  q.pop();

  // Add another string and then print ouf the front of the queue:
  q.push( "Illini" );
  std::cout << "Second pop(): " << q.front() << std::endl;

  return 0;
}

We can easily implement a queue using an array by just keeping track of array_index and counter_variable.


If we want to implement a queue using a linked list then we can implement it easily using a head pointer ( to insert/delete elements at front) and a tail pointer(for insert/removing elements from back) in order to do that the list will need to have back pointer besides next pointer.


Create,Push, Pop, Empty operations have a run time of O(1) for both cases of queue implementation using an array and linked list.



--------------------Lec 6 : Stack--------------------

Similar to a queue we also have stack that is a Last in First Out Data Structure. Stack is also ADT (Abstract Data Structure).

Stack ADT supports following operations similar to a queue that is :-
create  : Create a stack either using array or linked list. 
push    : Push a element on top of stack.
pop     : Removes a element from top of stack. 
empty   : Returns true if stack is empty.

Stack implementation is also provided us in C++ std/stl library and similar to queue , stack also supports template type.


Example : Stack

#include <iostream>
#include <stack>

int main() {
  // Create a std::stack:
  std::stack<std::string> s;

  // Add several strings to the stack:
  s.push( "Orange" );
  s.push( "Blue" );
  s.push( "Illinois" );

  // Print the front of the stack out and pop it off:
  std::cout << "First pop(): " << s.top() << std::endl;
  s.pop();

  // Add another string and then print ouf the front of the stack:
  s.push( "Illini" );
  std::cout << "Second pop(): " << s.top() << std::endl;

  return 0;
}

When we have array based implementation of stack then we will be pushing or inserting first element at last location of array and the last element at first position of array.
We will also need to keep track of insert locations i.e. current index of array where we pushed an element.


If our first array is full for example then we double the array as it takes O(log(n)) run time .


Linked List based implementation of stack is very easy i.e. to remove an element from start we just update the head pointer i.e. head_ptr = head_ptr->next;
To remove a element from last of linked list we update the tail pointer i.e. tail_ptr = tail_ptr->back;

To add a element in the start of a linked list we do tmp_ptr = head_ptr->next;
                                                     head_ptr->next = new_node;
                                                     new_node->next = tmp_ptr;
                                                
                                                        a->b->c->d

To insert e after a we do   a->e->b->c->d    i.e. tmp_ptr = a->next;
                                                  a->next=e;
                                                  e->next=tmp_ptr; where tmp_ptr contains address of node b;

Similarly we will be using back pointer if we want to add or remove a item or element from end of a list.



Note : Templated C++ code generally needs to be written entirely in header files; when we use templates, the compiler generates specific versions of the templated code at compile time, depending on how you tried to apply the template in your code. In order for the compiler to use the template, it first needs to know about the entire template, which is usually done by putting all the relevant parts in the header. 


For checking if a pointer is null we use if statement as : 
                           if(nullptr==ptr) or if(!ptr) Both statements check if ptr is null.

For checking if a pointer is not null we use if statement as
                           if(nullptr!=ptr) or if(ptr) Both statements  check if ptr is not null.  


