
*************************************************************************CPP Basics***********************************************************************


------------Variables Initialization--------------------------

type var_name (var_value);         // C++ constructor style initialization.
type var_name {var_value};         // C++11 style initialization 

We need to use second apart from constructors.


-----------------Casting For Objects and Types-------------------

https://en.cppreference.com/w/cpp/language/explicit_cast

static_cast<target-type>(expression)            :  Coverts a data type according to the mentioned type in <target-type>.
dynamic_cast<target-type>(expression)           :  Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.
const_cast< target-type >( expression )	        :  Returns a value of type target-type.	
reinterpret_cast< target-type >( expression )	:  Converts between types by reinterpreting the underlying bit pattern. 

-------------Namespaces-----------------

To use a specific name (Name of a class member function or variable) and avoid naming conflicts we use namespaces and encapsulate our code in a name space.
Names are given to parts of code to help reduce naming conflicts.
Third party frameworks will have their own namespaces.
We use scope resolution operator with a namespace :: 


using std::endl;  // Informing compiler that we are using endl from std library.
using std::cout;  // Informing compiler that we are using endl from std library.
using std::cin;   // Informing compiler that we are using endl from std library.

----------Using the sizeof operator----------------

sizeof operator just like in c provides us information about a specific type size in bytes.
To use sizeof operator on primitive data types like int,float,long,short,char first include these files climits and cfloat in your source code and then use sizeof operator on data types.

Example 1 : 
#include <climits>
#include <iostream>

int main(){
cout<<sizeof(int);
cout<<sizeof(float);
cout<<INT_MAX;    // Showing maximum value for INT type.
cout<<INT_MIN;    // Showing minimum value for INT type.
}


----------------------------constants in cpp-----------------------------------


Character Literal Constants : \n (newline) , \r (return)  , \t (tab) , \b (backspace),  \'  - single quote,   \" doble quote , \\ backslash
The character literal constants are used with cout statement.   

Constant expressions : constexpr 

Declared Constants : In c++ are decalred same to same like we used to do with C i.e. const var_name;

We should avoid using #define pre processor directive

---------------------------Vectors In Cpp----------------------------------------

vector is a object orineted template class.
vector is a container in c++ standard template library. 
Itś an array that can grow and shrink in size at execution time.
Provides bound checking.
Can use functions like : sort,reverse,find and e.t.c.

Whenever we use vector we are creating a object and we can perform several operations that are defined by vector class at : https://en.cppreference.com/w/cpp/header/vector


Vector Declaration : vector<type> vector_name;     

We can also initialize a vector just like arrays as : vector <type> vec_name (val1,val2);
To specify the size of a vector for a specific type we can declare a vector as : vector <type> vec_name (5);  // Now our vector will have a length of 5.


Example 1 : vector<int>   number {0,1,2,3};
            vector<float> temp {0.1,0.2};


------Accessing a vector element ----- 

Method 1 : 
To access a vector element then we can use the subscript notation [] with vector name i.e. vec_name[index] example temp[0] .
In the above method now we won´t be having bound checking and we have to do it ourselves.

Method 2 : vec_name.at(index) ;   Here we are using "at" method to access vector element at a index.

----------push_back(element)----------

vector method push_back will add a element at the end of vector just like a queue.

temp.push_back(0.35);       // now temp vector object will become temp {0.1,0.2,0.35};


-------vector inside a vector---------

A vector can also contain another vector i.e. vector<vector<type>> vec_name;

Example 2 : vector<vector<int>> movie_ratings 
              {
                  {0,1,2,3},
                  {22,33,34},
               }
This is just like a matrices. To access a element we will use row and column apprach just like we used to do it in arrays.

cout<<movie_ratings[0][0] ;    // now we won´t have bounds detection and we can get out of bounds error.

cout<<movie_rating.at(0).at(1);



------------------------------Range Based For Loop---------------------------------------


Introduced in C++11 standard.
Allows us to iterate over a vector,array, list or collection of elements without having to worry about length of collection incrementing,decrementing counter variable we do in a normal for loop. 

Syntax : for(var_type var_name : sequence)     // we can also use "auto" in place of var_type and compiler finds out the exact type to use.
        {
            statements;

        }

Example 1 : for (auto c : "Hello Usman")
            {

             if(c==' ')
                cout<<"\t";
                else 
               cout<<c;
            }



---------------------Conditional Operator------------------------

       (cond_expr) ? expr1 : expr2 

 cond_expr evalauates to a boolean expression
    if cond_expr is true then value of expr1 is returned.
    if cond_expr is false then value of expr2 is returned.
    
Similar to if else construct
Ternary operator
very useful when used inline.     


Example 1 : int a{10} , b{20};
            int score{92};
            int result {}
            
            result = (a>b) ? a:b;      // if a is greater than b then value of a is assigned to result, if not then value of b is assigned to result.
            result = (a<b) ? (b-a) : (a-b);
            result = (b!=0) ? (a/b) : 0;
            cout<<((score>90) ? "Excellent" : "Good" );
            
            
            
            
----------------------------------------Strings In C++------------------------------------

https://en.cppreference.com/w/cpp/string/basic_string

In C we used char arrays and char pointers for strings as there is not data type of string available to us in C.

To use C-style string functions ( strcpy(),strcat(),strcmp() )we must #include<cstring> header file in our C++ source code.

C Style string functions can only work with strings and characters terminated with null character \0.
We can use C style string library cstlib.h to convert C-Style strings to integer,float,long types.

C++ strings like C strings also start from index 0.

In C++ we´ve string data type available to us through string object defined in string namespace of std\stl library of C++.
C++ strings are : contigous in memory,
                  dynamic in size,
                  work with input and output streams
                  have lots of useful functions
                  can be easily converted to C style strings if needed
                  safer. 

On C++ strings objects we can perform all kinds of relational operations : == , !,  >  , < , >=   ,  <=
The string objects will be compared character by character lexically i.e. according to their ASCII codes.

Syntax :  string str_name1;
          
          string str_name2 {"str_value"};     // Here we have initialized string str_name2 with str_value
          
          string str_name3 {str_name2};       // Now string str_name3 contains string str_name2
          
          string str_name4 {"str_vale", num}  // Here we are only allocating num characters of string value str_vale to string str_name4
          
          string str_name5 { str_name3,0,2}   // Here we only assinging values of characters from index 0 to 2 of string str_name3 to string str_name5 
          
          string str_name6 { num, 'X' };      // now we can assign num times the character X to string str_name6

Syntax For Extracting a substring from a string : object.substr(start_index,length)     // Where object is declared as string object
                                                                                        // start index defining from where we start.
                                                                                        // length defining how many characters to extract from string.

Syntax For Searching a string or character inside a big string : object.find(search_string)    // The find method returns index of search string .


Syntax to find length of a string : object.length()   // Where object is defined as string object {};

Syntax for accessing string element at particular index _ object.at(index)       // Where object is defined as string object {};

             
Example 1 : 
          string s1;
          s1 = " M USMAN ";

          string s2;
          s2 = "MUS";
           
          string s3;
          s3 = s1 + s2 ;   now s3 becomes M USMAN MUS 

Example 2 : Extracting a substring from a string object

        string s1 = {" M USMAN"};
        cout<<s1.substr(0,2)<<"\n";
        cout<<s1.substr(2,3)<<"\n";

getline() : Method allows us to read a complete collection of strings and characters until a specific condition from cin input stream.

Example 3 : string s1;
            getline(cin,s1)      // Read entire line until \n
            
Example 4 : string s1;
            getline(cin,s1,'x');  // Reads entire line from input stream cin until x character.
            
                        
-------------------------------------Function Overloading In C++-------------------------------------------

Function Overloading means using the same function name for different types.

In C++ we can have same functions name for different parameters, the compiler automatically figures out which function should be called according to the type of passed parameters.

Characters are always promoted to integers by compilers and the called function if it have integer parameter then it will print itś ASCII code.

Example 1 : 

// Function Prototypes
int find_area(int side_length);
double find_area(double length,double width);

// Function Definition
int find_area(int side_length)
{
int area = side_length*side_length;    
return area;    
}

double find_area(double length,double width){
double area = length * width;    
return area ;    
}

-----------------------------------Pass By Reference------------------------------------

In C++ we can pass data through reference to any function.
Pass By reference is just alias i.e. we just assign a new name to the already assigned memory address of a variable with a type.
When we use const with reference then we inform the compiler that the value assigned cannot be changed itś similar to const qualifier.
The const in C++ is similar to const in C, When used with a type makes it read only and is allocated code memory. sub segment .rodata.




Example 1 : int height {98};
            int h3 = &height;    // Assigning new name to height variable.

Example 2: Passing A Variable By Reference To A function

sum(height)           // Passing Height variable address to sum function , 

void sum (int &h3)
{


}


Example 3 : Using const with reference

int main()   {
vector<int> data{1,2,3};
print(data);
return 0;
}

void print(const vector<int> &ref) 
{
ref.at(0) = 200;   // This statement will result in error as we have made our pass type reference const



}

---------------------Function Calls---------------------

Functions just like in C use stack to save their content during context switching or when returning back to a caller program.

Functions use call stack : LIFO Structure, push and pop.

Stack frame or Activation Record : 
   Functions must return control to caller .
   Each time a function is called we create a new activation record and push it on stack.
   When a function terminates we pop the activation record and return.
   Local variables and function parameters are allocated on the stack.


--------------------Pointers--------------------------


Pointer rules are same to same in C and C++.
Array names are actually the address of first element.

We can access elements of array through a pointer int *array_ptr = array;    
                                                  *(array_ptr)           // can also be done array_ptr;
                                                  *(array_ptr+1)         // can also be done array_ptr[1];  

We can compare two pointers as if(ptr1==ptr2) Here we are comparing the addresses of two pointers checking whether they point to same memory location or not.
                               if(*ptr1==*ptr2) Now we are comparing the data pointed out by pointers.  

If we subtract two pointers of same type then we get the number of elements in between the two pointers.


Dynamic Memory Allocation In C++ is done through new and delete which allocates and deallocates heap memory .
new returns a void pointer similar to malloc() and we need to caste it accordingly.
type *ptr {nullptr}; 
ptr = new type;  
ptr = new type [size];

To deallocate memory we use delete keyword just like free we have in C.

Example1 : int *ptr {nullptr};
           ptr = new int;
           delete ptr; 


Example 2 : int *array_ptr{nullptr};
            int size;
            array_ptr = new int[size];
            delete[] array_ptr;       // Used with delete [] because we have an array 





----------------------References------------------------------


We can have a constant reference for e.g. 

vector<string> stooges {"Larry","Mow", "Curly"};

for( auto const &str : stooges}   // Now we will be iterating on same memory location of stooges, without reference operator we had copied every element from vector index to str.
{
cout<< str<<"\n";
}

-------------------L values and R-Values--------------------------

L values are names that are addressable.
L values can be modified if not not defined as constants.

R values are non addressable and non assignable .
  A value thatś not an l value.
    Is on the right side of an assignment operation.
    a literal.
    a temporary which is intended to be non modifiable.
    
Example :     int x{100}; //    x is l value, 100 is r value
              int y{0};
              y = 100;
              x = x+y;   // r-value is (x+y) assigned to l value x
              
              
--------------------------------------------------Section 15 :Classes and Objects-------------------------------------------------------------              
              
We can perform similar operations on class objects as we do with variables like :  

We can have a vector of a certain class objects :                           vector<class_name> vec_name;  // Then we can push and pop class objects on vector and perform other operations.

We can have class object pointer.                                           Class_Name *object_ptr {nullptr};

We can also have an array of a certain class objects :                      Class_Name arr_name[] {object1,object2};

We can also assign heap address to a certain class object pointer:          Class *obj_ptr {nullptr};
                                                                            obj_ptr = new (Class_Name);


The above operations on class objects are exactly like we used to do with C structures.
             
              
              
-------------------Class Member Access Modifiers------------------------------

The access modifiers are quite similar to static and extern storage class we have in C.              

public : Methods/functions, Variables, Types are accessible everywhere i.e. any class client code can access them.
              
              
private : Methods/Functions, Variables, Types are only accessible by members of class or friends of class.

protected : Used with inheritance .             
                                        
Similar to a C module files .h and .c , In CPP a class also has declaration file .h and definition file  .cpp (containing class function/method implementations)
  
In Class definition file we follow this format when defining a function or method i.e return_type Class_Name::method_name{};
In Class declaration filewe follow this format when defining a method or function i.e. return_type method_name{};           
              
We can also have class member methods implemented in class declaration files .h this way is called implicitly inline.              
              
              
--------------------------------Constructors and Destructors-----------------------------------------

Constructors : are invoked during object creation
               Useful for initialization.
               Have same name as of class.
               No return type is specified.
               can be overloaded i.e. can given paramters or arguments which can be used at the time of invokation. 

Destructors :  Special Member method.
               Same name as the class proceeded with a tilde (~).
               Invoked automatically when an object is destroyed.
               No return type and no paramters.
               Only 1 destructor is allowed per class- cannot be overloaded.
               Useful to release memory and other resources.  
               Detructors are call´d in the reverse order i.e. most recent object gets popped out of the stack first.
               
Class destructor is called as soon as we get out of scope for an object similar to auto storage class variables of C programming.         
Once we define ourselves a class constructor then C++ compiler will not generate a default constructor for us so we will need to provide it ourselves.         
Classes can have as many constructors as necessary.
Each constructor has a unique signatue.

Note : Default Constructor with or without parameters is called when we create an object on heap with or without initializng it.
       Example : Class *obj_ptr = new Class (param1,param2,param3);


Always initialize object attributes through constructors otherwise they will contain garbage data and our object will be in a unknown state.      

Class Constructors and destructors are similar to auto stroage class of C where local variables are pushed and popped out of stack as we call and return a function.                


Example 1 : Class Player Default Constructors and Destructor Declaration
            
            class Player{
            
            private : 
            string name;
            int health;
            int xp;
            
            public : 
            Player();
            Player(string name);
            Player(string nam, int hea, int x)
            {
            name = nam;
            health = hea;
            xp = x,
            
            };
            ~Player();  // Destructor 
            }

int main(){

Player *enemy = new Player("Enemy",1000,0)    ; Here we have initialized our object on heap by the attributes. 
return 0;
}
             
              
--------------Constructor Initialization Lists------------------------

Construction Initialization Lists allow us : 
                     To initialize our object parameters more efficiently              
                     Initialization List immediately follows the parameter list.
                     Initializes the data members as the object is created.
                     Order of initialization is the order of declaration in the class.

Syntax : Constructor_Name::Constructor():Param1{Value},Param2{Value} 
         {

         };

                     
Example : class Person{

public :
uint8_t height{0};
uint8_t waist {0};
string name;
Person()
{

cout<<"Constructor Called"<<"\n";

};

Person(uint8_t h,uint8_t w,string n):height{h}:waist{w}:name{n}
{

cout<<"Constructor with parameter called \n";
};



~Person(){cout<<"Destructor Called"<<"\n";};



};
                     
----------Delegating Constructors--------------

One constructor calls another constructor and pass itś arguments to it for object attributes initialization.

Example 1 : Person::Person():Person{190,32,"Usman"}   // Now at first my delegated constructor will be call´d and then the calling constructor body will be executed.
{

};
                     
                     
-----------Constructor Parameters and Default Values------------------------

Sometimes we can use just one constructor instead of varying constructors with varying number of arguments enabling us to have less code.                      
Just assign some default values to the object parameters at the time of constructor declaration thatś it and provide constructor definition with parameters list that can be passed to it.
This type of constructor is useful when we don´t want to initialize each object attribute separately by each constructor.

Example 1 : 

In Class Declaration File : Person(uint8_t height=190,uint8_t waist = 0,string name="None");

In Class Definition File : Person::Person(uint8_t h,uint8_t w,string nam):height{h},waist{w},name{nam} 
			   {
			   cout<<"Constructor called with initializer list";
			   };

--------------Copy Constructor-----------------------

Copy Constructor is called when : 
     passing an object by value as a parameter.
     returing an object from a function by value.
     constructing an object based on another of the same class.
              
Best practices : Provide a copy constructor when your class has a raw pointer members
                 Provide the copy constructor with a const reference parameter.  
                 Use STL classes as they already provide copy constructors.
                 Avoid using raw pointer data members if possible.
                 
                 
Copy Constructor Declaration Syntax : Class_Name(const Class_Name &source)

Copy Constructor Definition :  Class_Name::Class_Name(const Class_Name &source) : Obj_param1{source.param1},Obj_param2{source.param2},Obj_param3{source.param3}
                               {
                               
                               };   

Copy Constructor is called like this : Class_Name Object1 {Object2};    // Here we are copying Object2 to Object1          

---------------------------Shallow Copy & Deep Copy Constructors-------------------------

The difference between Shallow Copy and Deep Copy is that in Shallow Copy we use the address of heap pointer and in deep copy we use value pointed out by that heap pointer.

In Shallow copy if we copy address of a location and then when later on the passed object pointing to that location getś out of scope then destructor frees up that location 
causing the object contaiing copied address to become unable to access that same memory location. This problem is similar to problem of dangling pointer of C language.

This problem of Shallow copy only occurs when we have a pointer in our class, we create heap pointer in a constructor with paramter and then we try to copy a object in copy constructor 
and use heap memory address which becomes later inaccessible when get out of scope.

Just derefence heap pointer by derefencing the reference of object and access the pointer. i.e. *obj_reference.pointer_name;


Example : Deep Copy 

Class Person.h file : 

Class Person{
private :        // We can also have it declared as public 
int *data{nullptr};

public :
void get_data_value();

};


Class Person.cpp file : 

Person::Person(int d)
{
*data = new int;
*data = d;
}


Person::Person(const Person &source):Person{*source.data}   // In Shallow constructor Is like this : Person::Person(const &source):Person{source.data}
{

}

Person::get_data_value()
{
return *data;
}

Person::~Person(){

delete data;

}



main.cpp file : 

void display_func(Person p3)    // Copy Constructor is called automatically by compiler to copy the source object Obj_p1 to destination object p3
{
cout<<p3.get_data_value()<<"\n";
}                               // Destructor is called heap memory pointed out by the object pointer data is freed i.e. p3.data is pointing to nothing
                                // In shallow copy constructor case we propagate this issue towards all objects and our program then crashes as all objects contain same address of
                                // heap location which is freed and becomes in accessible so value stored at that location is also lost.  


int main()
{

Person Obj_p1{100};

display_func(Obj_p1);          // 

Person Obj_P2{obj_P1};         // Copy constructor is called and we copy the object obj_P1 attributes into Obj_P2 even though 

return 0;

}

------------------------------Move Constructor---------------------------------------

C++11 introduced move semantics and move constructor.
Move constructor moves an object rather than copy it.
Copy elision it happens when C++ may optimize copying away completely (RVO-Return Value optimization).

We can only use move constructors for R values.

R-value references : Used by constructor and move assignment operator to efficiently move an object rather than copy it
                     R-value reference operator (&&).

Examples 1 : R value references

int &&r_ref = 200;
r_ref = 300

int &&r_ref = x ; // Compiler Error.

Rvalue references i.e. types have && before i.e. &&type

Example 2: void func(int &num);   // for l value
           void func(int &&num);  // for r value
           
           func(x);      // Calling l value function
           func(200) ;   // Calling R value function
        
We can have both L and R value functions in our code.                         

Move constructor : moves the resource.
                   Simply copies the address of resource from source to current object and nulls out the pointer in the source pointer 
                   
Hence Move constructor is very efficeint as compared to copy constructor as we move source object from one location to another leading to less memory consumption. 

Move Constructor Syntax : 
 In Class Declaration File : Class_Name(Class_Name &&source);
 
 In Class Definition File Class_Name::Class_Name(Class_Name &&source):Obj_Param{source.data}
                           {
                          source.data = nullptr;      // Where source.data means that source object heap pointer data , very similar to copy constructor . 
                          }                   
                   
Example 1 : 

Class Declaration File : 

// Move Constructor
Person(Person &&source);


Class Definition File : 

// Move Constructor
Person::Person(Person &&source):heap_ptr{source.heap_ptr},waist{source.waist}
{
cout<<"Move Constructor is called \n";
source.heap_ptr=nullptr;
}



// Move Constructor 
vector <Person> vec;
vec.push_back(Person{10});

-----------------The this pointer-----------------

"this" is a reserved keyword.
Contains address of the object in scope so itś a pointer to the object in scope.
Can only be used in class scope.
Can be used by programmer : 
   To access data member and methods.
   To determine if two objects are the same
   Can be dereferenced through *this to yield current object address.

---------------------------Using const with classes-----------------------------------

The effect of const on a class objects is same as we used const qualifier in C language on types.

When we use const with a class object declaration i.e. const Class Obj_Name , then that object attributes cannot be changed by any method nor it can be accessed .

To access a const object attribute using a method we need to mention const after itś prototype name.


Example 1 :

In class declaration File : Class Person
                            {
                            public :
                            int get_height() const;
                            }
In Class definition file : 
                           // Class Member Method
                           int Person::get_height() const   // If we don´t use const keyword then we cannot access object attribute
                            {
                            return height;  
                           }
                             
-------------------------Static Class Members-----------------------

static has same effect here on a class member variable.

static class member function can only access and work on static variable or type. 


In class declaration File : Class Person
                            {
                            public :
                            int get_height() const;
                            static int num;               // We cannot initialize static type here in class declaration
                            static int get_num();         // Static member function for accessing static type, function is returning int type
                            
                            }

In Class definition file :  int Person::num{0};          // Here we have initialized static member variable num to 0

                             int get_num()
                             {
                             return num;
                             }

Here static is also a strogage class like in C and a class member static variable will have a lifetime more than the function.

--------------------------------Structs vs Classes--------------------------------------

Members of a struct are public by default.   Same struct we used in C language
Members of a class are private by default.

Struct : Use struct for passive objects.
         Don´t declare methods in struct.
         
Class : Use class for active objects with private access.
        Implement getters/setters as needed.
        Implement member methods as needed.
        
--------------------------Friend of a class------------------------------

Friend : A function or class that has access to private class member.
         That function of or class is not a member of the class it is accessing.
         
Friend function   : Can be regular non-member functions.
                    Can be member methods of another class.
                                   
Friend class :   Another class that can access to private class members.        

Friendship is not symmetric . if A is a friend of B then B is not a friend of A.
Friendship is not transitive. if A is a friend of B and B is a friend of C then A is not a friend of C.


Scenarion 1 : When we have a non member function , we want to grant it access to class private variables, type we do :

In Class declaration :             class Class_Name
             				{
        			     friend ret_type func_name(Class_Name &s);  // &s means that this function is using a reference to access class private members             
                                     private : int data;
                                        };
In our source file .cpp : just put the definition of function and access or change class private members through reference.                                        

Scenario 2 :        When function belongs to another class 
In Class declaration :             class Class_Name
             				{
        			     friend ret_type Other_class::func_name(Class_Name &s);  // &s means that this function is using a reference to access class private members             
                                     private : int data;
                                        };
                                        
In our Other_class declaration file . h : 
                                   Just put the definition of function and access or change class private members through reference.
                                    class Other_class {
                                    ....
                                    public : 
                                    friend ret_type func_name(Class_Name &s){           // Here Class_Name refers to the class of whom private members we are accessing and modifying
                                    s.data=1;
                                    
                                    }
                                    };
                                     
Scenario 3 :     Adding Another class as a friend
                  
In class declaration file :                class Class_Name  
                                            {
                                            friend class Other_class;      // Now all methods of other class will have access to private members of this class
                                            std::string name;
                                            int health;
                                            int xp;
                                            private: int age;
                                            };
                      
----------------------------------------------Section 14 : Operator Overloading--------------------------------------------------


Operator Overloading allows us to use operators such as +,-,=,* to user defined types i.e. Class Objects.
Bascially operator overloading allows to perform mathematical arithmetic operations on C++ objects.

The operator overloading is not done automatically (except for assignment operator), they must be explicitly defined.

We cannot use these operatos with C++ objects they are    :: ,  :?  ,    .*    ,   .  ,  sizeof.

We can´t overload operators and expect same behavior with primitive C++ types i.e. int,double,e.t.c.

We can´t create new operators.

[] , () , -> and the assignment operator = must be declared as member methods.

We can also declare other operators as member methods or global functions.

When we overload operators for e.g like on Player class objects like : 
 p1<p2
 p1 == p2
 std::cout<<p1;
 
 Here we want to make sure that what does it means when we are comparing the two objects p1 and p2 i.e. are we comparing all of their attributes or only comparing one or few.

---------------------Copy Assignment Operator--------------------

Copy Assignment Operator is used when we want to assign one object to another
Copy Assignment Operator is also used when we assign a r value to a object already created.

Class_name obj1;
Class_name obj2;
obj1 = obj2;        // Here we want to use, 

obj1 = "value";     // Now first we will create a temporary object by calling default constructor with parameter, and copy r value from passed parameter into the temporary object.
                    // Then copy assignment operator is called to copy r value from temporary object to left side object obj1. 



Declaration Syntax : Type &::operator=(const Type &rhs); 

Definition : Type &Type::operator=(const Type &rhs) 
               {
                   if(this==rhs)
                      return *this;
                  
                   this-param = rhs.param;
                   return *this;

                }

Example :   Mystring &Mystring::operator=(const Mystring &rhs)
            {
                  if (this==&rhs)
                     return *this;
                  delete [] str;
                  
                  str = new char [std::strlen(rhs.str)+1];   
                  std::strcpy(str,rhs.str);
                  
                  return *this;

            }


----------------------Move Assignment Operator --------------------------

If we don´t provide move constructor then C++ compiler will assign copy constructor by default.

Just like Move constructor itś called on r values. 
The difference in between the two is that in move consructor we initialize the object with r value and in move assignment operator we assign a object the r value. 

Invoked at : obj = Class_Name{"Value"};           //Move Assignment Operator is called
             obj = "Value";                       //Move Assignment Operator.

Declaration Syntax : Type &operator=(Type &&rhs);    // Where Type is Class_Name

Definition :        Type & Type::operator=(Type &&rhs)
                     {
                        if(this==&rhs)
                            return *this;
                        delete [] ptr;        // In case class has a member cstyle pointer    
                        ptr = rhs.ptr;        // Copied the address to destination object pointer.   
                        rhs.ptr = nullptr;
                     return *this;     
                        
                      }



---------------------Unary Operators as member method (++,--,-,!)------------------

Unary operators represent operations that are performed on one operand.

The unary operators are ++,--,- & !. These operations are performed on objects and we need to implement methods for performing these operations on objects.

We need to provide a defintion of these operatos in our code.

Unary operators methods don´t accept any arguments.

Declaration :    Returntype operatorOp();	              //  Where Op can be ++, -- , - , &, !,  Returntype can be a class_name or a normal type like bool,float, e.t.c
                                                              //                                      
    
Definition :     Returntype Type::operatorOp() const          //  Where Op can be ++, -- ,- , & , !,  Returntype can be class_name or a normal type like bool,float, e.t.c                
                 {                                                                                    Type is the name of class of which this method is member

                 return type;
                 }
                 
Example 1 : Mystring operator- make lowercase
            
            Mystring larry1{"LARRY"};     
            Mystring larry2;
            
            larry1.display();      // LARRY
            
            larry2 = -larry1;       // larry1.operator-(), We need to implement this a member method of our class Mystring as mentioned in below.
            
            larry1.display();      // LARRY
            larry2.display();      // Displays larry after we convert object1 attribute str to lower case in following method definition


Operator method definition : 
           Mystring Mystring::operator-() const {
           
           char *buff = new char [std::strlen(str) +1];
           
           std::strcpy(buff,str);
           
           for(size_t i = 0; i<std::strlen(buff) ; i++)
              buff[i] = std::tolower
           Mystring temp{buff};  // We have initialized temp object pointer through constructor 
           delete[] buff;
           return temp;          // returning object.
           }
       
---------------------------------Pre Increment & Post Increment Operator Member Methods-------------------------------------------

// For ++a
Pre Increment Operator Method Declaration Syntax : Class_Name & operator++(Class_Name &a);  or  Class_Name & operator++();


Pre Increment Operator Member Method Definition :     // Pre Increment Operator
 						      Class_Name & Class_Name ::operator++()
						      {
  						       num=num+1;
   						       return *this;
						      }

// For a++
Post Increment Operator Member Method Declaration Syntax : Class_Name operator++(Class_Name &a,int); or Class_Name operator++(int); 


Post Increment Operator Method Definition :     Class_Name  Class_Name:: operator++(int)
                                                {
                                                Class_Name temp = *this;
						operator++();          // This statement is calling pre increment operator
						return temp;
						} 

Note : Pre-increment and pre-decrement operators increments or decrements the value of the object and returns a reference to the result.

Note : Post-increment and post-decrement creates a copy of the object, increments or decrements the value of the object and returns the copy from before the increment or decrement.


Example 1 : Number Number::operator-() const;     // This method is associated with a const object on which we are applying - operation.
            Number Number::operator++();          // pre-increment
            Number Number::operator++(int);       // post-increment
            bool Number::operator!() const;          
    
            Number n1 {100};
            Number n2 = -n1;
            n2 = ++n1;    // n1.operator++() , pre increment
            n2 = n1++;    // n1.operator++(int), post increment

// Pre Increment Operator
Mystring & Mystring ::operator++()
{
    num=num+1;
   return *this;
}

// Post Increment Operator ++
Number  Number:: operator++(int)
{
Number temp = *this;
operator++();
return temp;
}

-------------------Binary Operatos(+,-,==,!=,>,< etc) As Member Methods----------------

Binary operators (+,-,==,!=,>,< etc) are used to perform operation on two operands in our case they are two objects.

Declartion Syntax :  ReturnType operatorOp(const Type &rhs) const;        // Where operatorOp can be (+,-,==,!=,>,< etc) , const can be used if our objects are const
       
Definition Syntax :  ReturnType Type::operatorOp(const Type &rhs) const        // Where operatorOp can be (+,-,==,!=,>,< etc) , const can be used if our objects are const 
                     {                                                         // Where ReturnType can be anything , it can be bool or return object or e.t.c.
                                                                               // Where Type is class_name of which this method is part of.
                
                     }      

Example 1 :    
             Number Number::operator-(const Number &rhs) const;  
             Number Number::operator+(const Number &rhs) const;  
             bool Number::operator==(const Number &rhs) const;  
             bool Number::operator<(const Number &rhs) const;    // Here we are comparing two objects.

            Number n1{100} , n2{200};       // Where n1 and n2 are two objects initialized to 100,200.
            Number n3 = n1 + n2 ;           // n1.operator+(n2)
            n3 = n1 - n2;                   // n1.operator-(n2)
            if(n1==n2)                      // n1.operator==(n2), 
            n1.str{"USMAN}, n2.str{"UMAR"};
            if(n1==n2)                      // n1.operator==(n2) now we are comparing the attributes of objects in the following method as
            
            bool Number::operator==(const Number &rhs)
            {
            if(std::strcmp(str,rhs.str)==0 && num ==rhs.num)
              return true;
            else
               return false;                      
            }      
     
Example 2 : Mystring operator + (concatenation) 

Just like string we have in c++ we can also concatenate object string parameters using + operator by providing a member method definition.
We need to make sure that 1st parameter should be a object on left side in case of concatenating with cstyle strings.

Example : 
               Mystring larry {"Larry"};  
               Mystring moe{"Moe"};  
               Mystring stooges {is one of the"};
            
               Mystring result = larry + stooges; // We need to implement this functionality in a member method. 
                                                  // larry.operator+(stooges)
               
               result = moe + "is also a stooge";   // moe.operator+("is also a stooge "), need to implement this functionality in a member method as follows
            
               result = "Moe" + stooges;  //  This statement will result in error.

Implementation of concatenation operator for our class Mystring 
                
               Mystring Mystring::operator+(const Mystring &rhs) const
               {
               
               size_t buff_size = strlen(str) + strlen(rhs.str) +1;
               
               char *buff = new char[buff_size];   //Instead of heap we could also have used an array
               
               strcpy(buff,str);
               strcat(buff,rhs.str);
               
               Mystring temp{buff};     // Here we have created a temporary object, similar to like we used to create temp variables.
               
               delete [] buff;          // deleting allocated heap memory
               return temp;             // returning the object.
               
               }

------------------------Operator Overloading Using Global Functions---------------------------

The global functions based operators perform the same functionality of member methods on objects.
These global functions are declared as friends of a class instead as a member. If not declared as friend of class then need to use getter and setter methods for accessing certian class object attributes.


 ----------Unary Global Operators---------------
 
In case of Unary Operators global functions provide (++,--,-,!) functions .
Unary global operators have only one object in their parameter list.
Binary global operators have two objects in their parameter list.

Declaration Syntax : Returntype operatorop(Type &obj);

Examples 1 : Number operator-(const Number &obj)         // Where Number is the return type
           Number operator++(Number &obj)              // pre-increment
           Number operator++(Number &obj,int);         // post-increment
           bool operator!(const Number &obj);        
           
           Number n1{100}:
           Number n2 = -n1;
           n2 = ++n1;
           n2 = n1++;           

Example 2 :    Mystring larry1 {"LARRY"};  
               Mystring larry2;
               
               larry2 = -larry;    // operator-(larry1)     // Now we need to implement this functionlaity in our method as shown in the following defintion as: 

           Mystring operator-(const Mystring &obj)  {       // Where Mystring is return type , // Passed parameter as Object are of class Mystring.
           
           char *buff = new char [std::strlen(str) +1];
           
           std::strcpy(buff,str);
           
           for(size_t i = 0; i<std::strlen(buff) ; i++)
              buff[i] = std::tolower
           Mystring temp{buff};  // We have initialized temp object pointer through constructor 
           delete[] buff;
           return temp;          // returning object.
           }

-------------------Binary Operators Global Functions--------------------------

Binary operators as global functions perform operations of +,-,==,!=,<,>,e.t.c on two objects just like our Binary operators implemented as member functions.
Binary operators as global functions takes two objects as parameters.

Declaration Syntax : Returntype operatorOp(const Type &lhs,const Type &rhs)   // Where Return type can be a object or of primitive,derived and user defined type.

Examples 1 :    Number operator-(const Number &lhs,const Number &rhs) const;  
                Number operator+(const Number &lhs,const Number &rhs) const;  
                bool   operator==(const Number &lhs,const Number &rhs) const;  
                bool   operator<(const Number &lhs,const Number &rhs) const;    // Here we are comparing two objects.

                Number n1{100}, n2{200};
                Number n3 = n1 + n2;            // operator+(n1,n2), Now we will need to implement this functionality in our operator method definition
                n3 = n1 - n2;                   // operator-(n1,n2)
                if(n1==n2)                      // operator==(n1,n2)                   

                bool operator==(const Mystring &lhs, const Mystring &rhs)  
                {
                if(std::strcmp(lhs.str,rhs.str)==0)
                   return true;
                else 
                    return false;                   
                }
   Here in the above method definition we are only accessing str attribute of class becuase we have declared the method as friend of class otherwise we needed to use getter methods.


Example 2 :    Mystring larry {"Larry"};  
               Mystring moe{"Moe"};  
               Mystring stooges {is one of the"};
            
               Mystring result = larry + stooges; // We need to implement this functionality in a member method. 
                                                  // operator+(larry,stooges)
               
               result = moe + "is also a stooge";   // operator+(moe,"is also a stooge "), need to implement this functionality in a member method as follows
            
               result = "Moe" + stooges;  //  Okay with non member functions.

Implementation of concatenation operator for our class Mystring 
                
               Mystring operator+(const Mystring &lhs,const Mystring &rhs) const
               {
               
               size_t buff_size = strlen(lhs.str) + strlen(rhs.str) +1;
               
               char *buff = new char[buff_size];   //Instead of heap we could also have used an array
                              
               strcpy(buff,lhs.str);
               strcat(buff,rhs.str);
               Mystring temp{buff};     // Here we have created a temporary object, similar to like we used to create temp variables.
               
               delete [] buff;          // deleting allocated heap memory
               return temp;             // returning the object.
               
               }

--------------------Stream Insertion & Extraction Operators Overloading---------------------------

In stream insertion & extraction operators overloading we define and implement operations using insertion operator through cin>> and through extraction operator cout<<.
Basically we try to perform similar operations on objects by cin , cout statements using insertion >> and extraction operator <<.

Examples : Mystring larry;
           cin>> larry;       // here larry is a object, so we need to implement the functionlaity in our non member method where we are reading data into our object.
           
           Player hero;
           cin>>hero ;        // here hero is a object, so we need to implement the functionlaity in our non member method where we are reading data into our object.

Whenever we overload a operator the left had side of the object should be of the class to the rhs of object which in following case is not true i.e.

Mystring larry
larry<<cout;      // we need to implement this functionality in method definition

Player hero 
hero<<cout;      // we need to implement this functionality in method definition

----------stream insertion operator (<<)-----------

Used when we want to output data firectly from our object by cout<< statement.

Declaration Syntax : std::ostream & operator<<(std::ostream &os, const Class_Name &obj) 
          // When method is friend of class : friend std::ostream & operator<<(std::ostream &os, const Class_Name &obj); 


Definition : std::ostream & operator<<(std::ostream &os, const Class_Name &obj){
             os<<obj.str;          // if this method is a friend function of class, where str is a member variable of class.
             
             // os<<obj.get_str();  // if this method is not a friend function of class, where str is a member variable of class.
             
             return os;             // Returning the reference to ostream so we can keep inserting data into output stream i.e. display object data to console through cout<<
                                    // Don´t return ostream by value!    
               } 

--------stream extraction operator (>>)----------

Used when we wwant to insert data directly into our object by cin>> statement.

Declaration Syntax : std::ostream & operator<<(std::ostream &os, const Class_Name &obj) // When method is global and not a friend of class.
                   // When method is friend of class : friend std::ostream & operator<<(std::ostream &os, const Class_Name &obj);   

Definition : std::istream &operator>>(std::istream &is, Class_Name &obj) 
            {
            
  	    char *buff = new char [1000];
            is>>buff;
            obj=Class_Name{buff};
            delete [] buff;
            return is;          // Returning a reference to istream so we can keep inserting.
                                // Update the object passed in.
            }



----------------------------------------------------------Section 15 : Inheritance----------------------------------------------------------

Inheritance has following features : 

Provides a method for creating new classes from existing classes.
New class contains data and behaviors of existing class.
Allows for reuse of existing classes.
Allows us to focus on common attributes among set of classes.

Allows new classes to modify behaviors of exisitng classes to make it unique.
      Without actually modifying original class.



---------------------------------Terminology and Notation---------------------------------

Single Inheritance : A new class is creaed from existing classes , reuse mechanism.
Multiple Inheritance : A new class is created from two or more classes. 

The class derived from base class is called child class or sub class inherits attributes and operations from base class.


                    Base Class
                        ^
                        |
                    Derived Class 


Inheritance is transitive.



------------------Public Inheitance vs Composition--------------------

Both inheritance and composition allows reuse of existing classes.

Public Inheritance : 
    is-a relationship for e.g. 
    Employee is a Person.               Where Employee is a class derived from base class Person.
    Checking Account is a Account       Where Checking Account is a class derived from base class Account.
    Circle is a Shape.                  Where Circle is a class derived from base class Shape.
 
Composition : 
  has a relationship
      Person has a Account.            Where Person a class is using class Account however Person is not inherited from Account instead Person class has Account class code provided by inclusion of
                                       class Account header file in it i.e. #include<Account.h>
      Player has a special attack.     Where Player a class is using class special attack however Player is not inherited from Special Attack class.
      Circle has a location.           Where Circle a class is using class location however Circle is not derived from location class.


To make sure inheritance is perfectly suitable before applying inheritance step back and look at design and make sure itś suitable to be applied as inheritance adds more complexity in our code design.

Composition Example : 

#include "Account.h"
class Person{
std:: string name;       // has -a name
Account account;         // has-a account
};

------------------Deriving Classes from existing classes-------------------


C++ derivation syntax : 

Base Class In Class declaration file : Class Base {


				         };

Derived Class In Class Derivation File : Class Derived : access-specifier Base_Class {


                                          } 

Access specifier can be : public,private or protected. If no access specifier is provided then private inheritance is used.


Derived Class can have methods of the same name which are present in parent or base class.


------Types of inheritance in C++---------



public : Most common
         Establishes is-a relationship between derived and base classes.
         
private and protected : Establishes derived class has a base class relationship.
                        Is implemented in terms of relationship.
                        Different from composition.         




------------------Protected Mmbers and Class Access---------------------

Class Members (attributes, methods) declared with access specifier protected are : Accessible from the base class itself.
                                                                                   Accessible from classes derived from base.
                                                                                   Not Accessible by objects of Base or derived.
C++ derivation syntax : 

Base Class In Class declaration file : Class Base {

                                       protected:                     // Where access specifier can be private or protected.   
                                          
				         };

Derived Class In Class Derivation File : Class Derived : protected Base_Class {      // Where private or protected.


                                          } 


When we inherit a derived class from base class using access specifier protected then base class public members(attributes,methods) also get access specifier as protected.
Private members of base class are not accessible in derived class. Protected members are accessible only in Derived class. 

Protected memebrs of a base class are :  Accessible from the base class itself.
                                         Accessible from classes derived from base.
                                         Not accessible by objects of base or derived.


When we inherit a derived class from base class using access specifier private then base class public and protected members(attributes,methods) also get access specifier as private.
The private members of a base class cannot be accessed outside of base class.


----------------Constructors and Destructors-------------

Base part of derived object must be initialized first.
When a derived object is created then : 
    				Base class constructor executes then.
   				Derived class constructor executes.

------Constructors and Class Initialization----------

                                 Output
Base base;                       Base constructor Invoked     

Derived derived;                 Base constructor Invoked 
                                 Derived class object constructor invoked.
-----------Destructors----------

Class destructors are invoked in the reverse order as opposed to constructors in the case of inheritance.

Dervied class constructor is invoked first and then base class constructor is invoked.

Each destructor should free resources relevant to itś own class constructor.



A derived class does not inherit : 

  Base class constructors.
  Base class destructor.
  Base class overloaded assignment operators.
  Base class friend functions.
  
However the derived class constructors,destructors and overloaded assignment operators can invoke base class versions.

C++11 allows explicit inheritance of base non special constructors with : using Base::Base; anywhere in the derived class declaration.
Lots of rules involved, often better to define constructors overselves.  


---------------------Passing Arguments To Base Class Constructors----------------------

We can invoke any base class constructor we want in the initialization list of Derived class.

Syntax For Initializing Base Class Constructor : 

class Base {             Base Class

public : 
 Base();
 Base(int);
 .....
};

Derived::Derived(int x):Base(x),{optional initializers for derived}  // Here we are calling base class constructor first and then initializing derived class constructor attributes.
{
//Code                  // This code executes after both derived and base class constructors are invoked.

}  

------------------Copy/Move Constructors and Operator = with Derived Classes------------------

Often we don´t need to provide copy, move constructors and overloaded operator =
If we do not define them in derived class then the compiler will create them automatically and call the base class version.
If we do provide derived versions of copy, move constructors and of overloaded operator then we must invoke the base versions explicity ourselves.
We need to be careful about raw pointers in case base and derived clases have raw pointers. We need to provide them deep copy semantics.

Whenever we assign a derived object to another derived object then l-value derived class object copy assignment or move assignment operator is called and that copy assignment or move assignment operator calls first base class copy or move assignment operator and then performs the relevant operations in the copy assignment or move assignment operator method as shown below 


Example : In the following example we have not defined prototypes for class constructors,copy assignment operators, copy constructors. 

class Derived:public Base
{

private : 

int double_value;

public : 

Derived() : Base()    // Here base class no-args constructor is called

{ 
cout<<"Derived no-args constructor \n";
}

Derived(int x) : Base(x),double_value(x*2) // Here base class copy constructor is called
{ 
cout<<"int derived constructor \n";
}

Derived(const Derived &other) : Base(other),double_value(other.double_value) // Here base class copy assignment operator is called , compiler does the slicing i.e. separates base object from passed
                                                                             // derived object.
{ 
cout<<"Derived copy constructor \n";
}

Derived & operator=(const Derived &rhs)   // Derived class copy assignment operator
{ 
cout<<"Derived operator = \n";
if(this==&rhs)
return *this;
Base::operator=(rhs);             // Here we are invoking base class copy assignment operator
double_value = rhs.double_value;
}

~Derived();

}

-------------------Object Slicing C++--------------------------

When a derived class object is assigned to a base class object in C++, the derived class object’s extra attributes are sliced off (not considered) to generate the base class object; and this whole process is termed object slicing. In simple words, when extra components of a derived class are sliced or not used and the priority is given to the base class’s object this is termed object slicing. 


--------------------------------------Redefining Base Class Methods----------------------------------------------

Derived class can directly invoke base class methods.
Derived class can override or redefine base class methods.

Example : 
class Base
{
private :
double balance;
public :

void deposit(double amount) 
{
balance+=amount;
}

};


class Derived:public Base
{
public : 
void deposit(double amount)     // Redefining Base class method  
{
amount += some_interest;      
Base::deposit(amount);          // Invoking base class deposit method.    

}


};


To call a base class method and pass a argument to it just write this is in any derived class object : Base_Class_Name::Base_Method(argument);


Binding in C++ means what compiler understands at compile time i.e. how interprets the redefinition of base class methods in derived class and how it understands invoking of base class methods from 
derived class. It means which method version will be call´dby a relevant class object as when we redefine base class method in derived class then weǘe two methods with same name. 

The default bining for C++ is static.
Derived class objects will use Derived::deposit.
But we can explicitly invoke Base::deposit from Derived::deposit.

Dynamic binding is more powerful than static binding.


-----------Multiple Inheritance-------------

By multiple inheritance we mean that a derived class is derived from two or more base classes and we can do it as : 

Class Derived:public base1, public base2
{

// Derived class statements.


}

----------------------------------------------------------Section 15 : Polymorphism----------------------------------------------------------

There are two types of polymorphism : 

Compile-Time/Early Binding/ Static Binding :  
Function Overloading, Operator Overloading which we previously did and base class methods redefinition are forms of compile time or static polymorphism.
Static binding in C++ means that compiler matches a function call with correct defintion when we have a function with the same name but different parameters.


Run-Time Polymorphism : Enables us to assign different meanings to same function at run time.
Run time polymorphsim allows us to program more abstractly, Let C++ figure out which function to call at run time.

Run time polymorphism is achieven through : Inheritance, 
                                            Base class pointers or references, 
                                            virutal functions.

For dynamic polymorphism we must have : 
  Inheritance.
  Base Class pointer or base class reference.
  Virtual Functions. 
  
Example : Non Polymorphic In this example C++is doing static binding.

void display(const Account &acc)                       
{
acc.display();             // This line will always result in the call of base class display method 
}


Account a;                 // Account is our base class          
display_account(a);


Savings_Account b;         // Savings_Account is a derived from base class Account
display_account(b);        // Passing derived object to display method will result in function call of display method of base class account always, this is what static binding is
                           


Checking c;
display_account(c);


Trust d;
display_account(d);

Example : Polymorphic 

Account a;                 // Account is our base class          
display_account(a);


Savings_Account b;         // Savings_Account is a derived from base class Account
display_account(b);        // Passing derived object to display method will result in function call of display method of base class account always, this is what static binding is
                           


Checking c;
display_account(c);


Trust d;
display_account(d);

Account *p = new Trust;        // Here pointer p is pointing to a derived class trust object.
p->withdraw(1000);             // Now compiler will resolve it into trust::withdraw() , where withdraw is virtual in account.

-----Smart Pointers--------
Smart Pointer Declaration Syntax : std::unique_ptr<Type> pointer_name = std::make_unique<Type> ;
                                   pointer_name->method;
                                   
Example :                          std::unique_ptr<Base> ptr1 = std::make_unique<Derived>(); Where base and derived are our classes
                                   ptr1->say_hello(); 
     
Smart pointers don´t need to be deleted by delete statement.


----------------------------------------------------------Virtual Functions------------------------------------------------------------------

Virtual functions are : Redefined functions bound statically.
                        Overriden functions are bound dynamically.
                        Virtual functions are overridden.
                        Allows us to treat all objects generally as objects of the base class. 


-----------------------Declaring Virtual functions----------------------------

----------Declaration & Definition In Base Class-----------

Declare the function we want to override as virtual in the base class.
Virtual functions are virtual all the way down their hierarchy from this point.
Dynamic polymorphism is only possible through base claas pointer or reference.


We can also provide defintion of methods both virtual and non virutal in one source code file src.cpp

class Base_Name
{
public : 
virtual ret_type func_name(type parameters);
};

Definition : 
#include "Base_Name"

virtual ret_type func_name(type parameters)
{

}


---------Declaration & Definition In Derived class------------

Override the virtual function in derived class.
Function signatute and return type must match EXACTLY.
virtual keyword not required but is best practice.
if we don´t provide an overridden version it is inherited from itś base class then compiler will do static binding.

class Derived_Name : public Base_Name
{
public :
ret_type func_name(type parameters)
};

Definition : 

#include "Derived_Name"

virtual ret_type func_name(type parameters)
{

}

-------------------------------Virtual Destructors----------------------

If we have a derived class containing virtual function, itś object is destroyed by deleting itś storage via the base class pointer and the class has a non virtual destructor. Then the
behavior is undefined in C++ standard.

Derived objects must be destroyed in the correct order starting at the correct destructor.

To solve this problem we just provide a virtual destructor in our base class containing a virtual function, now all derived classes destructors become virtual too.
This virtual keyword needs to be mentioned with methods or functions at the time of declaration only if we are doing defintions in another source file, however when doing
defintion and declaration in one file then just mention virtual one time with defitnion of method which is also the declaration.



--------Declaration--------

class Base_Name {
public : 
virtual return_type func_name(type param);
virtual ~Base_Name();   // Virtual class destructor.
};


class Derived_Name : public Base_Name
{
public :
ret_type func_name(type parameters);
virtual ~Derived_Name();   // Virtual Derived class destructor.
};



-------Defintion---------

#include "Base_Name"

virtual ret_type Base_Name::func_name(type parameters)
{

}


virtual Base_Name::~Base_Name()             // Virtual Destructor for base class.
{

}


#include "Derived_Name"

virtual ret_type Derived_Name::func_name(type parameters)
{

}


virtual Derived_Name::~Derived_Name()             // Virtual Destructor for base class.
{

}


We cannot have virtual constructors.

-------------------Using the C++11 Override Specifier-------------------

We already redefine base class virtual functions in our derived classes however keeping in mind that the function signature should be same, otherwise it will be statically bound
and compiler will consider it as function redefinition.
C++11 standard provides override specifier allows us to override base class virtual functions by changing there function signature slightly.
Overriding is dynamically bound.
override specifier needs to be mentioned with virtual methods or functions at the time of declaration only if we are doing defintions in another source file, however when doing
defintion and declaration in one file then just mention override as postfix one time with defitnion of method which is also the declaration.



Example : Declaring and Defining Functions For both base and derived class in one source file

class Base_Name {
public : 
virtual return_type func_name(type param) const
{
cout<<" I am base class method";
}

virtual ~Base_Name{};   // Virtual class destructor.

};


class Derived_Name : public Base_Name
{
public :

virtual ret_type func_name(type parameters) const override
{
cout<<"I am derived class";

}

virtual ~Derived_Name{};   // Virtual Derived class destructor.


};


In main.c file : 

Base *ptr1 = new Base();
ptr1->Base_method();         // Result in "I am base class method"


Base *ptr2 = new Derived();
ptr2->Derived_method();      // Result in "I am derived class method"



-------------------Using the C++11 Final Specifier-------------------


The final specifier like the override specifier is also provided by C++11 standard. 

When final specifier used with a class then it prevents that class from being derived i.e. we cannot derive sub classes from a class.

When final specifier is used at method or function level then it prevents that method from being overriden in derived classes.


Example : When used with a class.
 
class My_class final    // Now we cannot have sub classes of this class.
{
..

};

class Derived final : public Base {     // Now this derived class cannot be further derived.


};


Example : When used with a virtual function 

class A final    // Now we cannot have sub classes of this class.
{
public : 
virtual void_do_something();
};

class B final : public A 
{                                  
virtual void_do_something() final;   // Prevent from being further overridden.

};

class C : public B 
{

virtual void_do_something();                // This statement will produce a compiler error as this class as earlier specified by final specifier cannot be further derived.


};

------------------------------Polymorphism Using Base Class References-------------------------------


We can also use base class references for dynamic polymorphsim provided our base class methods are  : 
                                         
                                         Declared with keyword virtual and Derived class methods are declared with override specifier.

Useful when we pass objects to functions that expect a base class reference.
 
Example 1 :
 
Account a;
Account &ref1;
ref2.withdraw(1000);    // Account::withdraw, dynamic binding.

Trust t;
Account &ref2 = t;
ref1.withdraw(1000);   // Trust::withdraw, dynamic binding.



Note : Every compiler vendoris indepednent to implement dynamic polymorphism using virtual functions independently according to their design.



---------------------------------------------Pure Virtual Functions and Abstract Classes------------------------------------------------------


Abstract class : The class that cannot be instantiated through objects.
                 Only used as base class in inheritance hierarchies.
                 


                 The virtual functions of a base class should be declared in class declaration file as : virtual ret_type func_name(passed_arguments) = 0;
                 
                 class Base             // Abstract Base class
                 {
                 public : 
                 virtual ret_type func_name(passed_arguments) = 0;  // Pure virtual function.
                 }  
                  
                 The abstract class virtual functions don´t have any implementation but are implemented in concrete classes i.e. classes derived from abstract class.                 
                 
Concrete class :  The concrete class is derived from abstract class and can be instantiated from objects and also contains defintions for virutal functions previously 
                  decalred in base class.
                   
                  class Derived 
                  {
                  
                  public :
                  virtual ret_type func_name(passed_arguments) override  
                  {
                    cout<<"Drawing_Line"; 
                  };                  
                  
                  }

In our main source file : 

int main()
{
 
                Base &ref;
                Derived d;
                ref = d;
                d.func_name();

}      
     

        
In the above scenario we have decalred and defined classes in one source .c file thatś why didn´t removed virtual and override keywords with function definitions. 



------------------------------------Abstract Classes as Interfaces-----------------------------------------

An abstract class has only pure virtual functions.
These functions provide a general set of services to the user of the class.
This class is inherited as public.
Each subclass is free to implement these services as needed.
Every service (method) must be implemented.
The service type information is strictly enforeced.


C++ does not provide true interfaces.
We use abstract classes and pure virtual functions to achieve it.

Note : Abstract class derived from interface class can have simple implementations of the pure virtual functions later needed to be overriden in derived classes and this abstract class 
       should also have it+s own constructor which will be called from derived class constructor however this abstract class cannot be instantiated.
      
       The abstract class derived from interface class cannot override the virtual methods of the interface class unlike the sub classes derived from it.

Example : 

I_Tv.h file :   class I_Tv            // Where I_Tv is our Abstract Interface Class
		{
		friend ostream & operator<<(ostream &os,const I_Tv &ref);
		
		public : 
		virtual return_type method_name() = 0;                    // Pure Virtual Function
		virtual return_type method_name(ostream &os) const = 0 ;  // Pure Virtual Function
                };

I_Tv.cpp :     #include "I_Tv.h"

		ostream & operator<<(ostream &os,const I_Tv &ref)
		{
		ref.print(os);
		return os;
		}

Tv.h file :     class Tv : public I_Tv                                   // Derived Class which is our abstract class for other sub classes, This abstract class can have simple implementations
                {                                                        // Of virtual functions but they then need to be overriden in derived classes . This abstract class need to also have
                                                                         // itś own constructor as it will be initialized through derived class constructor however it cannot be instantiated  
                public :                                                 // through objets.
                return_type mtehod_name(ostream &os) const override;
                virtual bool method_name() override;
                virtual ~Tv();
                }

Tv.cpp file :   #include "Tv.h"

		return_type Tv::method_name(ostream &os) const 
		{
		os<<"Hello In Tv Class \n";
		}

		return_type Tv::method_name()
		{
		cout<<"Volume Increased \n";
		return true;
		}


Lcd.h file :    #include "Tv.h"
                class Tv : public Tv                                   // Derived class inheriing both Abstract Tv and Interface class I_Tv 
                {       

                public :
                virtual return_type mthod_name(ostream &os) const override;
                virtual bool method_name()override;
                virtual ~Lcd();
                }

Lcd.cpp file :   #include "Lcd.h"

		return_type Tv::method_name(ostream &os) const 
		{
		os<<"Hello In LCD Derived Class \n";
		}

		return_type Tv::method_name()
		{
		cout<<"LCD Volume Increased \n";
		return true;
		}

main.c file :

Lcd l1;                       // creating a lcd derived class object named l1  
I_Tv *lcd_ptr = &l1;          // Creating a Base Interface class I_Tv pointer and copying address of derived class object l1. 
lcd_ptr->method_name();       // Outputs to "LCD Volume Increased"
cout<<*ptr;                   // Outputs to "Hello In LCD Derived Class"; 

Tv tv1;
I_Tv *tv_ptr = &tv1;          // Creating a Base Interface class I_Tv pointer and copying address of derived class object l1. 
tv_ptr->method_name();        // Outputs to "TV Volume Increased"
cout<<*tv_ptr;                // Outputs to "Hello In TV Derived Class"; 



------------------------------------Chapter 17 : Smart Pointers----------------------------------


Some Potential Issues With Raw Pointers : 

Uninitialized (wild) Pointers : Pointer not initialized to NULL and then used in program.
Memory Leaks : Heap Memory Pointer lost in a local function or program block and thus we fail to deallocate heap memory.
Dangling Pointers : Pointer pointing to a storage thinking itś valid but itś been deallocated. This issue will occur when we use double pointers ( pointer containing address of another pointer)
                    i.e **ptr.
Not Exception Safe.


C++ Smart Pointers are  : Objects.
                          They can only point to heap allocated memory.
                          Automatically call delete when no longer needed.
                          Adhere to RAII (Resource Acquisition Initialization) Principles. 

Types of C++ Smart Pointers are : Unique Pointers (unique_ptr).
                                  Shared Pointers (shared_ptr). 
                                  Weak Pointers   (weak_ptr). 
                                  Auto Pointers   (auto_ptr).    Deprecated.

Smart Pointers are provided in memory header file containing smart pointer classes and functions so we need to include it in our source file i.e. : #include <memory>

C++ smart pointers are  : Defined by class templates.
                          Wrapped around a raw pointer.
                          Support Overloaded Operators i.e. Dereference *, Member selection ->  
                          Don´t support pointer arithmetic.
                          Can have custom deleters.

Syntax of declaring a smart pointer is : std::smart_pointer<Smart_Pointer_Class> ptr_name = memory_addres; 
     
                                          // Where Smart Pointer Class can be : 
                                                                           shared_ptr, 
                                                                           unique_ptr,
                                                                           weak_ptr.

                                                                                                                                       
When we declare a smart pointer object then that object is placed on stack as all smart pointers are objects and are placed on stac just like normal raw pointers


---------------RAII - RESOURCE ACQUISITION IS INITIALIZATION------------------------------

RAII is a common idion or pattern used in software design based on container object lifetime.

RAII objects are allocated on stack.

   .Resource Acquisition Can Be : Open a file,  
                                  Allocation Of Memory.
                                  Acquires a lock.
   .Is initialization :   Resource is acquired in a constructor.   
 
   .Resource relinquishing  :  Happens in destructor for e.g. close the file, deallocating memory, release lock.

So it means smart pointers which are actually objects have methods, constructors and destructors for acquistion,initialization and deinitialization/relinquishing purposes.


Each Smart Pointer Object supports multiple useful methods such as : 
                                                            ptr.get()        for accessing underlying raw pointer address.
                                                            ptr.reset()      for initializing underlying raw pointer to nullptr. 
                                                            ptr->get_data()  for accessing data pointed by raw pointer.
                                       

---------C++11 Smart Pointer : unique_ptr----------

unique_ptr smart pointers cannot be shared i.e. every unique_ptr smart pointer is unique . itś similar to restrict type qualifier case when used with C.

Example 1 : Creating, intializing and using unique_ptr

          { 
             std::unique_ptr<int> ptr1 {new int{100} };
             cout<<*ptr1 ;
             *ptr1=200;
             cout<<*ptr1;
         }

unique_ptr - useful methods
        
         
        {
            std::unique_ptr<int> ptr {new int {100} };  
            cout<<ptr.get();    // this statement will print the address of smart pointer which is basically the address of underlying associated raw pointer 
            ptr.reset();        // now ptr is initialized to nullptr
            
            if(ptr)             // checking is pointer ptr is not null
        }  // ptr automatically deleted   

 We can also compare smart unique pointers.
 
 Example 2 : 
            {
             std::unique_ptr<Account> ptr {new Account {"Larry"}};   // Here our unique pointer is pointing to an object of type Account class.
             std::cout<<*ptr.      // operator overloaded method will be called for object     
             ptr->deposit(1000);   // Accessing object methods.
             ptr->withdraw(500);
 
 
            }
 
Example 3 : unique_ptr - vectors and move 
                 {
             
             vector<unique_ptr<int>> vec;  // vector is created containing unique_ptr pointing to integers.
             
             unique_ptr<int> ptr {new int{100} };
             
             vec.push_back(ptr)   ;        // this statement will result into error
             
             vec.push_back(move(ptr);      // this statement will move the smart unique pointer to vector as ptr object gives up the ownership of pointer
                                           // the vector then owns the pointer and initializes the pointer to null. this is just like a object.    
            }
 
 --------unique_ptr -make_unique (C++14)------------

C++14 provides us make_unique keyword for initializing and creating a type T and assign it to the unique_ptr in one step. The unique_ptr actually replaces the new keyword.
 
Syntax : std::unique_ptr<type> ptr_name = make_unique<type> (initialization_values);

Example 4: 
        {
             unique_ptr<int> p1 = make_unique<int>(100);
             unique_ptr<Account> p2 = make_unique<Account>("Curly",5000);                
             auto p3 = make_unique<Player>("Hero",100,100);  // creating an object of class player type, providing initialization values to constructor.
                                                             // compiler is automatically deducing the type for pointer p3 so we don´t need to define the type of it.
                                                             // like unique_ptr<type> ptr_name = address or unique_ptr<type> ptr_name {new Type {initialization value} }; 
        }

-----------------------shared_ptr Smart Pointer------------------------------

This smart pointer provides shared ownership of heap objects.

shared_ptr<T> :  points to an object of type T on the heap.
                 shared pointer is not unique - there can be many shared pointers (shared_ptr)s pointing to the same object on the heap.
                 Establishes shared ownership relationship.
                 Can be assigned and copied unlike unique_ptr smart pointer.
                 Can be moved.
                 Doesn´t support managing arrays by default.
                 When the use count is zero , managed object on the heap is destroyed.  

Shared Pointer Creation Syntax : std::shared_ptr<type> ptr_name = memory_address or in case of heap do std::shared_ptr<type> ptr_name {new type{value} };

Example 5 : Creating, intializing and using shared_ptr

          { 
             std::shared_ptr<int> ptr1 {new int{100} };
             cout<<*ptr1 ;
             *ptr1=200;
             cout<<*ptr1;
         }

Example 6 : When we have multiple shared smart pointers all pointing to same memory address 
            we can use use_count() method to count the number of pointers pointing to same memory location, just a counter variable in use_count method.
             
         using std::shared_ptr;
         {
         
         shared_ptr<int> p1 {new int {100} };
         cout<<p1.use_count()<<"\n";
         
         shared_ptr<int> p2 {p1};
         cout<<p1.use_count()<<"\n";    // outputs to 2 as now 2 pointers are pointing to shared memory.
         
         p1.reset();                    // decrementing the use count while p1 is nulled out.
         cout<<p1.use_count();          // outputs to 0     
         cout<<p2.use_count();          // outputs to 1       
         }

Example 7 : 
             {
             std::shared_ptr<Account> ptr {new Account {"Larry"}};   // Here our unique pointer is pointing to an object of type Account class.
             std::cout<<*ptr.      // operator overloaded method will be called for object     
             ptr->deposit(1000);   // Accessing object methods.
             ptr->withdraw(500);
            }

Example 8 : 

             {
             
             vector<shared_ptr<int>> vec;  // vector is created containing unique_ptr pointing to integers.
             shared_ptr<int> ptr {new int{100} };
             vec.push_back(ptr)   ;        // Now this statement in case of shared pointer will not result into error and we don´t need to use move method.
            
             cout<<ptr.use_count();        // Outputs to 2 as we have two pointers one in the vector and one here ptr pointing to heap memory.           
               
            }
 
-------------shared_ptr-make_shared C++11-------------------------------
Example 9 :
        {
             shared_ptr<int> p1 = make_shared<int>(100);                // here our use_count is 1
             shared_ptr<int> p2 {p1};                                   // here our use_count is 2 
             shared_ptr<int> p3;               
             p3 = p1;                                                   // here our use_count is 3 , as shared pointer like unique pointer is also a object so itś 
                                                                        // copied using default copy constructor.
        }
make_shared is more efficient as compared to new keyword as compiler will generate more efficient code.


Example 10 : 
       using std::shared_ptr;  
       using std::vector;
       using std::shared_ptr;
       using std::cout; 
       using std::endl;      
       int main()
       {
       shared_ptr<Account> acc1 = make_shared<Trust_Account>("Larry",1000,3.1); 
       shared_ptr<Account> acc2 = make_shared<Trust_Account>("Moe",5000); 
       shared_ptr<Account> acc3 = make_shared<Savings_Account>("Curly",6000);
 
       vector<shared_ptr<Account>> accounts;     
       acounts.push_back(acc1);                 
       acounts.push_back(acc2);  
       acounts.push_back(acc3);
      
      for(const auto &acc : accounts) 
      { 
            cout<<*acc<<std::endl;
            cout<<"Use count"<<acc.use_count();        // For each shared pointer acc1, acc2, acc3 use_count will be 2 as vector accounts also have same shared pointers with same address for 
                                                       // each heap memory locations created and pointed by shared pointers acc1,acc2,acc3.        
      } 
                                                
      return 0;                                        // Here at first vector accounts shared pointers will be de initialized, then shared pointers acc1,acc2,acc3 will be 
                                                       // deinitialized get out of scope and then shared pointers acc1,acc2,acc3 will be deinitalized and then heap memory will be deallocated or freed.
      
      }

----------------Weak Pointers---------------------


weak_ptr<T> :    Smart Pointer that does ot own a memory space unlike other smart pointers.
                 Provides a non owning weak reference.
                 Points to an object of type T on the heap.
                 Does not participate in owning relationship.
                 Always created from a shared_ptr.   
                 Does not increment or decrement reference use case.
                 Used to prevent strong reference cycles which could prevent objects from being deleted.


Syntax of declaring a weak smart pointer : std::weak_ptr<Type> ptr_name;


--------------------------Custom Deleters---------------------------------


Smart Pointers are objects so when a smart pointer is destroyed there associated destrucotr is automatically called and compiler deallocates the heap and other associated resources, This entire
process of deinitialization is done automatically unlike raw pointers we don´t have to explicitly releae heap and other resources.

Sometimes we would like to do more than just releasing heap memory for that purpose smart pointers provide custom deleters just like custom destructos we made earlier with class objects.
One should note that custom deleters are not custom destructors in fact relevant destructors for smart pointers will be called automatically by compiler after execution of custom deleter. 


There are lots of ways to write custom deleters but we will cover custom deleter made through functions and custom deleter made through lambdas.

When we are using custom deleters then we cannot use make_unique or make_shared methods for creating and allocating objects on heap and assigning address to smart pointers.


-----------------Custom Deleters-Function-------------------------

Example : 
void my_deleter(Test *ptr)        // Where ptr is our raw pointer
{
// your custom deleter code
delete ptr;
}


shared_ptr<Test> ptr {new Test{},my_deleter}        // Here as soon as smart pointer shared_ptr gets out of scope then custom deleter function named as my_deleter will be called.


----------------Custom Deleters-Lambda--------------------------

Lambda is a anonymous inline function i.e. a function with no name, this function is called as soon as smart poiner gets out of scope.

Example : shared_ptr<Test> ptr (new Test{100}, [] (Test *ptr)    // Where Test is our class, and in ptr (new Test{100}, [] (Test *ptr) we are creating and allocating heap, returning address to shared
                                                                 // smart pointer ptr, The lambda function is [](Test *ptr) 
          {
            cout<<"\tUsing my custom deleter "<<"\n";
            delete ptr;
          });


-----------------------------------------------------------------------Section 18 : Exception Handling--------------------------------------------------------------

Exception Handling should be used only for synchronous code not for asynchronous code.


Exception handling is : Dealing with extraordinary situations.
                        Indicates that an extraordinary situation has been detected or has occurred. 
                        Program can deal with extraordinary situations in a suitable manner.

Causes Of Exceptions : Insufficient Resources.
                       Missing resources. 
                       Invalid Operations.  
                       Range Violations.    
                       Underflows and Overflow.
                       Illegal data and others. 

Exception Safe : When our code handles exceptions ( very difficult in C++).


---------------------Exception Handling------------------------

C++ Syntax Of Exception Handling : 

throw  : throws an exception 
         followed by an argument.
         
try{ code that may throw an exception }         
         we place code that may throw an exception in a try block.
         if the code throws an exception the try block is exited.
         the thrown exception is handled by a catch handler.
         if no catch handler exists the program terminates.

catch(Exception ex)      {code to handle the exception}
         code that handles exception.
         can have multiple catch handlers.
         may or may not cause programs to terminate. 

Exception Handling Example :
           
        double average {};      
        try
        {
        
        if(exception_condtion=value);
        {
             throw exception_value;
        }
         average = sum/total;              // This statement will execute only when no exception occurs.         
        }

        catch(type &ex)                    // Eception Handler Code.
        {
          cerr<<" can´t divide by zero "<<"\n";
        }
           

Any function which can throw a function is placed in try block for e.g. i.e.

Example : Throwing Exception From Function

double calculate_avg(int sum,int total) 
{
   if(total==0)
     throw 0;                                       // Here C++ will be unwinding the stack looking for the function containing the catch handler and if no handler is found then program terminates
                                                    // in a un predictable way.
   return static_cast<double>(sum)/total;  
}

double average{};

try
{
average = calculate_avg(sum,total);
cout<<average<<"\n";
}
catch(int &ex)   
{
cerr<<"You can´t divide by zero"<<"\n";
}
cout<<"Bye"<<"\n";


-----------------------------Handling Multiple Exceptions------------------------------------

We can throw multiple exceptions from a function.

To throw multiple exceptions we just need to have multiple catch handlers i.e. exception handlers according to the thrown value.


Example : Catching multiple exceptions from a function

double miles_per_gallon{};

double calculate_mpg(int miles, int gallons)
{

if(gallons == 0)
 throw 0;

if(miles < 0 || gallons < 0 )
 throw std::string {"Negative value error"};

return static_cast<double> (miles)/gallons;
}

try
{

miles_per_gallon = calculate_mpg(miles,gallon);  // Call´d function throwing exceptions
cout<<miles_prer_gallon<<"\n";

} 

catch(int &ex)
{
cerr<<"You can´t divide by zero";<<"\n";
}

catch(string &ex)
{
cerr<<ex;<<"\n";
}


catch(...)                   // This is a general purpose catch handler where we can throw all types and values, but we don´t have access to exception type.
{ 
cerr<<"Unknown Exception"; 
}



cout<<"Bye"<<"\n";


------------------------Stack Unwinding------------------------------

Stack unwinding is a process occurs when a exception is thrown but not handled in the current scope then C++ tracks and finds relevant exception handler while traversing through all the functions relvant to the call stack.
In Stack unwinding function in which exception was not caught terminates and is removed from the call stack.
If a try block was used to then catch blocks are checked for a match.
If no try block was used or the catch handler doesn´t match stack unwinding occurs again.
If the stack is unwounded back to main and no catch handler handles the exception the program terminates.



-----------------------Creating User-Defined Exception Classes-----------------..

We can create exception classes and throw instances of those classes.

When we have exception classes then : Best practice is to throw an object not a primitive type.
                                      Throw an object by value.   
                                      Catch an object by reference (or const reference).



Example : 

class DivideByZeroException
{


};

class NegativeValueException
{


};


double calculate_mpg(int miles,int gallons) 
{

if (gallons == 0) 
  throw DivideByZeroException();              // Here we are throwing user defined exception class, In our case we are using default constructor. 

if (miles < 0 || gallons < 0) 
  throw DivideByZeroException();              // Here we are throwing user defined exception class, In our case we are using default constructor. .

return static_cast<double>(miles)/gallons;
  


}


so catch block can catch an object by vale and also by reference and address ( when we use pointer).



-----------------------------------Class Level Exceptions-------------------------------------
  
Exceptions can also be thrown from within a class.

Method      :    These work the same way as they do for functions as weǘe seen.

Constructor :    Constructors may fail ( Heap alllocation fails, file cannot be opened or some other resource allocation, initialization, condition check)
                 Constructors do not return any value.   
                 Throw an exception in the constructor if you cannot initialize an object.

Destructor :     Do not throw exceptions from your destructor.     
 

---------------------------Exception Class Hierarchy----------------------------------------

C++ provides a class hierarchy of excpetion classes.
   std::exception is the base class.
   all subclasses implement the what() virtual function.
   we can create our own user defined exception subclasses.

virtual const char *what() const noexcept;   // This function returns a C-Style string with a description of the exception that has occurred.
 

Example : Deriving our class from std::exception


The following class is declared and defined in the same file.

class IllegalBalanceException: public std::exception                   
{
public : 
IllegalBalanceException() noexcept = default;    // The keyword noexcept means that no exception will occur in the method, default means that default construcotr is provided.
~ĨllegalBalanceException() = default;

virtual const char* what() const noexcept       // The keyword noexcept means that no exception will occur in the method.   
{
return "Illegal balance exception";
}


};



Account Class Modified Constructor :

Accout::Account (std::string name,double balance) : name{name}, balance{balance} 
{
if(balance < 0.0 )
 throw IllegalBalanceException{};     // Here we are throwing object
}


Creating an Account Object : 


try 
{
std::unique_ptr<Account> moes_account = std::make_unique<Checking_Account>("Moe",-100.0);
std::cout<<"Use moes_account"<<std::endl;
}

catch (const IllegalBalanceException &ex)
{
std::cerr<<ex.what()<<std::endl;
}




















































































































































